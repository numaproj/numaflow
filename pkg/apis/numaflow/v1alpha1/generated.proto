/*
Copyright 2022 The Numaproj Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/


// This file was autogenerated by go-to-protobuf. Do not edit it manually!

syntax = "proto2";

package github.com.numaproj.numaflow.pkg.apis.numaflow.v1alpha1;

import "k8s.io/api/core/v1/generated.proto";
import "k8s.io/apimachinery/pkg/api/resource/generated.proto";
import "k8s.io/apimachinery/pkg/apis/meta/v1/generated.proto";
import "k8s.io/apimachinery/pkg/runtime/generated.proto";
import "k8s.io/apimachinery/pkg/runtime/schema/generated.proto";

// Package-wide variables from generator "generated".
option go_package = "github.com/numaproj/numaflow/pkg/apis/numaflow/v1alpha1";

// AbstractPodTemplate provides a template for pod customization in vertices, daemon deployments and so on.
message AbstractPodTemplate {
  // Metadata sets the pods's metadata, i.e. annotations and labels
  // +optional
  optional Metadata metadata = 1;

  // NodeSelector is a selector which must be true for the pod to fit on a node.
  // Selector which must match a node's labels for the pod to be scheduled on that node.
  // More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
  // +optional
  map<string, string> nodeSelector = 2;

  // If specified, the pod's tolerations.
  // +optional
  repeated k8s.io.api.core.v1.Toleration tolerations = 3;

  // SecurityContext holds pod-level security attributes and common container settings.
  // Optional: Defaults to empty.  See type description for default values of each field.
  // +optional
  optional k8s.io.api.core.v1.PodSecurityContext securityContext = 4;

  // ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec.
  // If specified, these secrets will be passed to individual puller implementations for them to use. For example,
  // in the case of docker, only DockerConfig type secrets are honored.
  // More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod
  // +optional
  // +patchMergeKey=name
  // +patchStrategy=merge
  repeated k8s.io.api.core.v1.LocalObjectReference imagePullSecrets = 5;

  // If specified, indicates the Redis pod's priority. "system-node-critical"
  // and "system-cluster-critical" are two special keywords which indicate the
  // highest priorities with the former being the highest priority. Any other
  // name must be defined by creating a PriorityClass object with that name.
  // If not specified, the pod priority will be default or zero if there is no
  // default.
  // More info: https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/
  // +optional
  optional string priorityClassName = 6;

  // The priority value. Various system components use this field to find the
  // priority of the Redis pod. When Priority Admission Controller is enabled,
  // it prevents users from setting this field. The admission controller populates
  // this field from PriorityClassName.
  // The higher the value, the higher the priority.
  // More info: https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/
  // +optional
  optional int32 priority = 7;

  // The pod's scheduling constraints
  // More info: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/
  // +optional
  optional k8s.io.api.core.v1.Affinity affinity = 8;

  // ServiceAccountName applied to the pod
  // +optional
  optional string serviceAccountName = 9;

  // RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used
  // to run this pod.  If no RuntimeClass resource matches the named class, the pod will not be run.
  // If unset or empty, the "legacy" RuntimeClass will be used, which is an implicit class with an
  // empty definition that uses the default runtime handler.
  // More info: https://git.k8s.io/enhancements/keps/sig-node/585-runtime-class
  // +optional
  optional string runtimeClassName = 10;

  // AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.
  // +optional
  optional bool automountServiceAccountToken = 11;

  // Set DNS policy for the pod.
  // Defaults to "ClusterFirst".
  // Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'.
  // DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy.
  // To have DNS options set along with hostNetwork, you have to specify DNS policy
  // explicitly to 'ClusterFirstWithHostNet'.
  // +optional
  optional string dnsPolicy = 12;

  // Specifies the DNS parameters of a pod.
  // Parameters specified here will be merged to the generated DNS
  // configuration based on DNSPolicy.
  // +optional
  optional k8s.io.api.core.v1.PodDNSConfig dnsConfig = 13;
}

message AbstractVertex {
  optional string name = 1;

  // +optional
  optional Source source = 2;

  // +optional
  optional Sink sink = 3;

  // +optional
  optional UDF udf = 4;

  // Container template for the main numa container.
  // +optional
  optional ContainerTemplate containerTemplate = 5;

  // Container template for all the vertex pod init containers spawned by numaflow, excluding the ones specified by the user.
  // +optional
  optional ContainerTemplate initContainerTemplate = 6;

  // +optional
  optional AbstractPodTemplate abstractPodTemplate = 7;

  // +optional
  // +patchStrategy=merge
  // +patchMergeKey=name
  repeated k8s.io.api.core.v1.Volume volumes = 8;

  // Limits define the limitations such as buffer read batch size for all the vertices of a pipeline, will override pipeline level settings
  // +optional
  optional VertexLimits limits = 9;

  // Settings for autoscaling
  // +optional
  optional Scale scale = 10;

  // List of customized init containers belonging to the pod.
  // More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
  // +optional
  repeated k8s.io.api.core.v1.Container initContainers = 11;

  // List of customized sidecar containers belonging to the pod.
  // +optional
  repeated k8s.io.api.core.v1.Container sidecars = 12;

  // Number of partitions of the vertex owned buffers.
  // It applies to udf and sink vertices only.
  // +optional
  optional int32 partitions = 13;

  // Names of the side inputs used in this vertex.
  // +optional
  repeated string sideInputs = 14;

  // Container template for the side inputs watcher container.
  // +optional
  optional ContainerTemplate sideInputsContainerTemplate = 15;
}

message Authorization {
  // A secret selector which contains bearer token
  // To use this, the client needs to add "Authorization: Bearer <token>" in the header
  // +optional
  optional k8s.io.api.core.v1.SecretKeySelector token = 1;
}

// BasicAuth represents the basic authentication approach which contains a user name and a password.
message BasicAuth {
  // Secret for auth user
  // +optional
  optional k8s.io.api.core.v1.SecretKeySelector user = 1;

  // Secret for auth password
  // +optional
  optional k8s.io.api.core.v1.SecretKeySelector password = 2;
}

// Blackhole is a sink to emulate /dev/null
message Blackhole {
}

message BufferServiceConfig {
  optional RedisConfig redis = 1;

  optional JetStreamConfig jetstream = 2;
}

// CombinedEdge is a combination of Edge and some other properties such as vertex type, partitions, limits.
// It's used to decorate the fromEdges and toEdges of the generated Vertex objects, so that in the vertex pod,
// it knows the properties of the connected vertices, for example, how many partitioned buffers I should write
// to, what is the write buffer length, etc.
message CombinedEdge {
  optional Edge edge = 1;

  // From vertex type.
  optional string fromVertexType = 2;

  // The number of partitions of the from vertex, if not provided, the default value is set to "1".
  // +optional
  optional int32 fromVertexPartitionCount = 3;

  // +optional
  optional VertexLimits fromVertexLimits = 4;

  // To vertex type.
  optional string toVertexType = 5;

  // The number of partitions of the to vertex, if not provided, the default value is set to "1".
  // +optional
  optional int32 toVertexPartitionCount = 6;

  // +optional
  optional VertexLimits toVertexLimits = 7;
}

// Container is used to define the container properties for user defined functions, sinks, etc.
message Container {
  // +optional
  optional string image = 1;

  // +optional
  repeated string command = 2;

  // +optional
  repeated string args = 3;

  // +optional
  repeated k8s.io.api.core.v1.EnvVar env = 4;

  // +optional
  repeated k8s.io.api.core.v1.EnvFromSource envFrom = 5;

  // +optional
  repeated k8s.io.api.core.v1.VolumeMount volumeMounts = 6;

  // +optional
  optional k8s.io.api.core.v1.ResourceRequirements resources = 7;

  // +optional
  optional k8s.io.api.core.v1.SecurityContext securityContext = 8;

  // +optional
  optional string imagePullPolicy = 9;
}

// ContainerTemplate defines customized spec for a container
message ContainerTemplate {
  // +optional
  optional k8s.io.api.core.v1.ResourceRequirements resources = 1;

  // +optional
  optional string imagePullPolicy = 2;

  // +optional
  optional k8s.io.api.core.v1.SecurityContext securityContext = 3;

  // +optional
  repeated k8s.io.api.core.v1.EnvVar env = 4;

  // +optional
  repeated k8s.io.api.core.v1.EnvFromSource envFrom = 5;
}

message DaemonTemplate {
  // +optional
  optional AbstractPodTemplate abstractPodTemplate = 1;

  // Replicas is the number of desired replicas of the Deployment.
  // This is a pointer to distinguish between explicit zero and unspecified.
  // Defaults to 1.
  // More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#what-is-a-replicationcontroller
  // +optional
  optional int32 replicas = 2;

  // +optional
  optional ContainerTemplate containerTemplate = 3;

  // +optional
  optional ContainerTemplate initContainerTemplate = 4;
}

message Edge {
  optional string from = 1;

  optional string to = 2;

  // Conditional forwarding, only allowed when "From" is a Sink or UDF.
  // +optional
  optional ForwardConditions conditions = 3;

  // OnFull specifies the behaviour for the write actions when the inter step buffer is full.
  // There are currently two options, retryUntilSuccess and discardLatest.
  // if not provided, the default value is set to "retryUntilSuccess"
  // +kubebuilder:validation:Enum=retryUntilSuccess;discardLatest
  // +optional
  optional string onFull = 4;
}

// FixedWindow describes a fixed window
message FixedWindow {
  // Length is the duration of the fixed window.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Duration length = 1;

  // +optional
  // Streaming should be set to true if the reduce udf is streaming.
  optional bool streaming = 2;
}

message ForwardConditions {
  // Tags used to specify tags for conditional forwarding
  optional TagConditions tags = 1;
}

message Function {
  // +kubebuilder:validation:Enum=cat;filter
  optional string name = 1;

  // +optional
  repeated string args = 2;

  // +optional
  map<string, string> kwargs = 3;
}

// GSSAPI represents a SASL GSSAPI config
message GSSAPI {
  optional string serviceName = 1;

  optional string realm = 2;

  // UsernameSecret refers to the secret that contains the username
  optional k8s.io.api.core.v1.SecretKeySelector usernameSecret = 3;

  // valid inputs - KRB5_USER_AUTH, KRB5_KEYTAB_AUTH
  optional string authType = 4;

  // PasswordSecret refers to the secret that contains the password
  // +optional
  optional k8s.io.api.core.v1.SecretKeySelector passwordSecret = 5;

  // KeytabSecret refers to the secret that contains the keytab
  // +optional
  optional k8s.io.api.core.v1.SecretKeySelector keytabSecret = 6;

  // KerberosConfigSecret refers to the secret that contains the kerberos config
  // +optional
  optional k8s.io.api.core.v1.SecretKeySelector kerberosConfigSecret = 7;
}

message GeneratorSource {
  // +kubebuilder:default=5
  // +optional
  optional int64 rpu = 1;

  // +kubebuilder:default="1s"
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Duration duration = 2;

  // Size of each generated message
  // +kubebuilder:default=8
  // +optional
  optional int32 msgSize = 3;

  // KeyCount is the number of unique keys in the payload
  // +optional
  optional int32 keyCount = 4;

  // Value is an optional uint64 value to be written in to the payload
  // +optional
  optional uint64 value = 5;

  // Jitter is the jitter for the message generation, used to simulate out of order messages
  // for example if the jitter is 10s, then the message's event time will be delayed by a random
  // time between 0 and 10s which will result in the message being out of order by 0 to 10s
  // +kubebuilder:default="0s"
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Duration jitter = 6;
}

message GetDaemonDeploymentReq {
  optional string isbSvcType = 1;

  optional string image = 2;

  optional string pullPolicy = 3;

  repeated k8s.io.api.core.v1.EnvVar env = 4;

  optional k8s.io.api.core.v1.ResourceRequirements defaultResources = 5;
}

message GetJetStreamServiceSpecReq {
  map<string, string> labels = 1;

  optional int32 clusterPort = 2;

  optional int32 clientPort = 3;

  optional int32 monitorPort = 4;

  optional int32 metricsPort = 5;
}

message GetJetStreamStatefulSetSpecReq {
  optional string serviceName = 1;

  map<string, string> labels = 2;

  optional string natsImage = 3;

  optional string metricsExporterImage = 4;

  optional string configReloaderImage = 5;

  optional int32 clusterPort = 6;

  optional int32 clientPort = 7;

  optional int32 monitorPort = 8;

  optional int32 metricsPort = 9;

  optional string serverAuthSecretName = 10;

  optional string serverEncryptionSecretName = 11;

  optional string configMapName = 12;

  optional string pvcNameIfNeeded = 13;

  optional string startCommand = 14;

  optional k8s.io.api.core.v1.ResourceRequirements defaultResources = 15;
}

message GetRedisServiceSpecReq {
  map<string, string> labels = 1;

  optional int32 redisContainerPort = 2;

  optional int32 sentinelContainerPort = 3;
}

message GetRedisStatefulSetSpecReq {
  optional string serviceName = 1;

  map<string, string> labels = 2;

  optional string redisImage = 3;

  optional string sentinelImage = 4;

  optional string metricsExporterImage = 5;

  optional string initContainerImage = 6;

  optional int32 redisContainerPort = 7;

  optional int32 sentinelContainerPort = 8;

  optional int32 redisMetricsContainerPort = 9;

  optional string credentialSecretName = 10;

  optional bool tlsEnabled = 11;

  optional string pvcNameIfNeeded = 12;

  optional string confConfigMapName = 13;

  optional string scriptsConfigMapName = 14;

  optional string healthConfigMapName = 15;

  optional k8s.io.api.core.v1.ResourceRequirements defaultResources = 16;
}

message GetSideInputDeploymentReq {
  optional string isbSvcType = 1;

  optional string image = 2;

  optional string pullPolicy = 3;

  repeated k8s.io.api.core.v1.EnvVar env = 4;

  optional k8s.io.api.core.v1.ResourceRequirements defaultResources = 5;
}

message GetVertexPodSpecReq {
  optional string isbSvcType = 1;

  optional string image = 2;

  optional string pullPolicy = 3;

  repeated k8s.io.api.core.v1.EnvVar env = 4;

  optional string sideInputsStoreName = 5;

  optional k8s.io.api.core.v1.ResourceRequirements defaultResources = 6;
}

// GroupBy indicates it is a reducer UDF
message GroupBy {
  // Window describes the windowing strategy.
  optional Window window = 1;

  // +optional
  optional bool keyed = 2;

  // AllowedLateness allows late data to be included for the Reduce operation as long as the late data is not later
  // than (Watermark - AllowedLateness).
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Duration allowedLateness = 3;

  // Storage is used to define the PBQ storage for a reduce vertex.
  optional PBQStorage storage = 4;
}

message HTTPSource {
  // +optional
  optional Authorization auth = 1;

  // Whether to create a ClusterIP Service
  // +optional
  optional bool service = 2;
}

message IdleSource {
  // Threshold is the duration after which a source is marked as Idle due to lack of data.
  // Ex: If watermark found to be idle after the Threshold duration then the watermark is progressed by `IncrementBy`.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Duration threshold = 1;

  // StepInterval is the duration between the subsequent increment of the watermark as long the source remains Idle.
  // The default value is 0s which means that once we detect idle source, we will be incrementing the watermark by
  // `IncrementBy` for time we detect that we source is empty (in other words, this will be a very frequent update).
  // +kubebuilder:default="0s"
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Duration stepInterval = 2;

  // IncrementBy is the duration to be added to the current watermark to progress the watermark when source is idling.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Duration incrementBy = 3;
}

// +genclient
// +kubebuilder:object:root=true
// +kubebuilder:resource:shortName=isbsvc
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Type",type=string,JSONPath=`.status.type`
// +kubebuilder:printcolumn:name="Phase",type=string,JSONPath=`.status.phase`
// +kubebuilder:printcolumn:name="Message",type=string,JSONPath=`.status.message`
// +kubebuilder:printcolumn:name="Age",type=date,JSONPath=`.metadata.creationTimestamp`
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +k8s:openapi-gen=true
message InterStepBufferService {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional InterStepBufferServiceSpec spec = 2;

  // +optional
  optional InterStepBufferServiceStatus status = 3;
}

// InterStepBufferServiceList is the list of InterStepBufferService resources
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message InterStepBufferServiceList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated InterStepBufferService items = 2;
}

message InterStepBufferServiceSpec {
  optional RedisBufferService redis = 1;

  optional JetStreamBufferService jetstream = 2;
}

message InterStepBufferServiceStatus {
  optional Status status = 1;

  optional string phase = 2;

  optional string message = 3;

  optional BufferServiceConfig config = 4;

  optional string type = 5;
}

message JetStreamBufferService {
  // JetStream version, such as "2.7.1"
  optional string version = 1;

  // Redis StatefulSet size
  // +kubebuilder:default=3
  optional int32 replicas = 2;

  // ContainerTemplate contains customized spec for NATS container
  // +optional
  optional ContainerTemplate containerTemplate = 3;

  // ReloaderContainerTemplate contains customized spec for config reloader container
  // +optional
  optional ContainerTemplate reloaderContainerTemplate = 4;

  // MetricsContainerTemplate contains customized spec for metrics container
  // +optional
  optional ContainerTemplate metricsContainerTemplate = 5;

  // +optional
  optional PersistenceStrategy persistence = 6;

  // +optional
  optional AbstractPodTemplate abstractPodTemplate = 7;

  // Nats/JetStream configuration, if not specified, global settings in numaflow-controller-config will be used.
  // See https://docs.nats.io/running-a-nats-service/configuration#limits and https://docs.nats.io/running-a-nats-service/configuration#jetstream.
  // For limits, only "max_payload" is supported for configuration, defaults to 1048576 (1MB), not recommended to use values over 8388608 (8MB) but max_payload can be set up to 67108864 (64MB).
  // For jetstream, only "max_memory_store" and "max_file_store" are supported for configuration, do not set "store_dir" as it has been hardcoded.
  // +optional
  optional string settings = 8;

  // Optional arguments to start nats-server. For example, "-D" to enable debugging output, "-DV" to enable debugging and tracing.
  // Check https://docs.nats.io/ for all the available arguments.
  // +optional
  repeated string startArgs = 9;

  // Optional configuration for the streams, consumers and buckets to be created in this JetStream service, if specified, it will be merged with the default configuration in numaflow-controller-config.
  // It accepts a YAML format configuration, it may include 4 sections, "stream", "consumer", "otBucket" and "procBucket".
  // Available fields under "stream" include "retention" (e.g. interest, limits, workerQueue), "maxMsgs", "maxAge" (e.g. 72h), "replicas" (1, 3, 5), "duplicates" (e.g. 5m).
  // Available fields under "consumer" include "ackWait" (e.g. 60s)
  // Available fields under "otBucket" include "maxValueSize", "history", "ttl" (e.g. 72h), "maxBytes", "replicas" (1, 3, 5).
  // Available fields under "procBucket" include "maxValueSize", "history", "ttl" (e.g. 72h), "maxBytes", "replicas" (1, 3, 5).
  // +optional
  optional string bufferConfig = 10;

  // Whether encrypt the data at rest, defaults to false
  // Enabling encryption might impact the performance, see https://docs.nats.io/running-a-nats-service/nats_admin/jetstream_admin/encryption_at_rest for the detail
  // Toggling the value will impact encrypting/decrypting existing messages.
  // +optional
  optional bool encryption = 11;

  // Whether enable TLS, defaults to false
  // Enabling TLS might impact the performance
  // +optional
  optional bool tls = 12;
}

message JetStreamConfig {
  // JetStream (NATS) URL
  optional string url = 1;

  optional NatsAuth auth = 2;

  // +optional
  optional string streamConfig = 3;

  // TLS enabled or not
  optional bool tlsEnabled = 4;
}

message JobTemplate {
  // +optional
  optional AbstractPodTemplate abstractPodTemplate = 1;

  // +optional
  optional ContainerTemplate containerTemplate = 2;

  // ttlSecondsAfterFinished limits the lifetime of a Job that has finished
  // execution (either Complete or Failed). If this field is set,
  // ttlSecondsAfterFinished after the Job finishes, it is eligible to be
  // automatically deleted. When the Job is being deleted, its lifecycle
  // guarantees (e.g. finalizers) will be honored. If this field is unset,
  // the Job won't be automatically deleted. If this field is set to zero,
  // the Job becomes eligible to be deleted immediately after it finishes.
  // Numaflow defaults to 30
  // +optional
  optional int32 ttlSecondsAfterFinished = 3;

  // Specifies the number of retries before marking this job failed.
  // More info: https://kubernetes.io/docs/concepts/workloads/controllers/job/#pod-backoff-failure-policy
  // Numaflow defaults to 20
  // +optional
  optional int32 backoffLimit = 4;
}

message KafkaSink {
  repeated string brokers = 1;

  optional string topic = 2;

  // TLS user to configure TLS connection for kafka broker
  // TLS.enable=true default for TLS.
  // +optional
  optional TLS tls = 3;

  // +optional
  optional string config = 4;

  // SASL user to configure SASL connection for kafka broker
  // SASL.enable=true default for SASL.
  // +optional
  optional SASL sasl = 5;
}

message KafkaSource {
  repeated string brokers = 1;

  optional string topic = 2;

  optional string consumerGroup = 3;

  // TLS user to configure TLS connection for kafka broker
  // TLS.enable=true default for TLS.
  // +optional
  optional TLS tls = 4;

  // +optional
  optional string config = 5;

  // SASL user to configure SASL connection for kafka broker
  // SASL.enable=true default for SASL.
  // +optional
  optional SASL sasl = 6;
}

message Lifecycle {
  // DeleteGracePeriodSeconds used to delete pipeline gracefully
  // +kubebuilder:default=30
  // +optional
  optional int32 deleteGracePeriodSeconds = 1;

  // DesiredPhase used to bring the pipeline from current phase to desired phase
  // +kubebuilder:default=Running
  // +optional
  optional string desiredPhase = 2;

  // PauseGracePeriodSeconds used to pause pipeline gracefully
  // +kubebuilder:default=30
  // +optional
  optional int32 pauseGracePeriodSeconds = 3;
}

message Log {
}

message Metadata {
  map<string, string> annotations = 1;

  map<string, string> labels = 2;
}

message NativeRedis {
  // Redis version, such as "6.0.16"
  optional string version = 1;

  // Redis StatefulSet size
  // +kubebuilder:default=3
  optional int32 replicas = 2;

  // RedisContainerTemplate contains customized spec for Redis container
  // +optional
  optional ContainerTemplate redisContainerTemplate = 3;

  // SentinelContainerTemplate contains customized spec for Redis container
  // +optional
  optional ContainerTemplate sentinelContainerTemplate = 4;

  // MetricsContainerTemplate contains customized spec for metrics container
  // +optional
  optional ContainerTemplate metricsContainerTemplate = 5;

  // +optional
  optional ContainerTemplate initContainerTemplate = 6;

  // +optional
  optional PersistenceStrategy persistence = 7;

  // +optional
  optional AbstractPodTemplate abstractPodTemplate = 8;

  // Redis configuration, if not specified, global settings in numaflow-controller-config will be used.
  // +optional
  optional RedisSettings settings = 9;
}

// NatsAuth defines how to authenticate the nats access
message NatsAuth {
  // Basic auth which contains a user name and a password
  // +optional
  optional BasicAuth basic = 1;

  // Token auth
  // +optional
  optional k8s.io.api.core.v1.SecretKeySelector token = 2;

  // NKey auth
  // +optional
  optional k8s.io.api.core.v1.SecretKeySelector nkey = 3;
}

message NatsSource {
  // URL to connect to NATS cluster, multiple urls could be separated by comma.
  optional string url = 1;

  // Subject holds the name of the subject onto which messages are published.
  optional string subject = 2;

  // Queue is used for queue subscription.
  optional string queue = 3;

  // TLS configuration for the nats client.
  // +optional
  optional TLS tls = 4;

  // Auth information
  // +optional
  optional NatsAuth auth = 5;
}

// NoStore means there will be no persistence storage and there will be data loss during pod restarts.
// Use this option only if you do not care about correctness (e.g., approx statistics pipeline like sampling rate, etc.).
message NoStore {
}

// PBQStorage defines the persistence configuration for a vertex.
message PBQStorage {
  // +optional
  optional PersistenceStrategy persistentVolumeClaim = 1;

  // +optional
  optional k8s.io.api.core.v1.EmptyDirVolumeSource emptyDir = 2;

  // +optional
  optional NoStore no_store = 3;
}

// PersistenceStrategy defines the strategy of persistence
message PersistenceStrategy {
  // Name of the StorageClass required by the claim.
  // More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
  // +optional
  optional string storageClassName = 1;

  // Available access modes such as ReadWriteOnce, ReadWriteMany
  // https://kubernetes.io/docs/concepts/storage/persistent-volumes/#access-modes
  // +optional
  optional string accessMode = 2;

  // Volume size, e.g. 50Gi
  optional k8s.io.apimachinery.pkg.api.resource.Quantity volumeSize = 3;
}

// +genclient
// +kubebuilder:object:root=true
// +kubebuilder:resource:shortName=pl
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Phase",type=string,JSONPath=`.status.phase`
// +kubebuilder:printcolumn:name="Message",type=string,JSONPath=`.status.message`
// +kubebuilder:printcolumn:name="Vertices",type=integer,JSONPath=`.status.vertexCount`
// +kubebuilder:printcolumn:name="Sources",type=integer,JSONPath=`.status.sourceCount`,priority=10
// +kubebuilder:printcolumn:name="Sinks",type=integer,JSONPath=`.status.sinkCount`,priority=10
// +kubebuilder:printcolumn:name="UDFs",type=integer,JSONPath=`.status.udfCount`,priority=10
// +kubebuilder:printcolumn:name="Age",type=date,JSONPath=`.metadata.creationTimestamp`
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +k8s:openapi-gen=true
message Pipeline {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional PipelineSpec spec = 2;

  // +optional
  optional PipelineStatus status = 3;
}

message PipelineLimits {
  // Read batch size for all the vertices in the pipeline, can be overridden by the vertex's limit settings.
  // +kubebuilder:default=500
  // +optional
  optional uint64 readBatchSize = 1;

  // BufferMaxLength is used to define the max length of a buffer.
  // Only applies to UDF and Source vertices as only they do buffer write.
  // It can be overridden by the settings in vertex limits.
  // +kubebuilder:default=30000
  // +optional
  optional uint64 bufferMaxLength = 2;

  // BufferUsageLimit is used to define the percentage of the buffer usage limit, a valid value should be less than 100, for example, 85.
  // Only applies to UDF and Source vertices as only they do buffer write.
  // It will be overridden by the settings in vertex limits.
  // +kubebuilder:default=80
  // +optional
  optional uint32 bufferUsageLimit = 3;

  // Read timeout for all the vertices in the pipeline, can be overridden by the vertex's limit settings
  // +kubebuilder:default= "1s"
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Duration readTimeout = 4;

  // RetryInterval is the wait time before retrying a batch after getting an error from a user defined processor or ISBSVC.
  // +kubebuilder:default= "0.001s"
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Duration retryInterval = 5;
}

// +kubebuilder:object:root=true
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message PipelineList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated Pipeline items = 2;
}

message PipelineSpec {
  // +optional
  optional string interStepBufferServiceName = 1;

  // +patchStrategy=merge
  // +patchMergeKey=name
  repeated AbstractVertex vertices = 2;

  // Edges define the relationships between vertices
  repeated Edge edges = 3;

  // Lifecycle define the Lifecycle properties
  // +kubebuilder:default={"deleteGracePeriodSeconds": 30, "desiredPhase": Running, "pauseGracePeriodSeconds": 30}
  // +optional
  optional Lifecycle lifecycle = 4;

  // Limits define the limitations such as buffer read batch size for all the vertices of a pipeline, they could be overridden by each vertex's settings
  // +kubebuilder:default={"readBatchSize": 500, "bufferMaxLength": 30000, "bufferUsageLimit": 80}
  // +optional
  optional PipelineLimits limits = 5;

  // Watermark enables watermark progression across the entire pipeline.
  // +kubebuilder:default={"disabled": false}
  // +optional
  optional Watermark watermark = 6;

  // Templates are used to customize additional kubernetes resources required for the Pipeline
  // +optional
  optional Templates templates = 7;

  // SideInputs defines the Side Inputs of a pipeline.
  // +optional
  repeated SideInput sideInputs = 8;
}

message PipelineStatus {
  optional Status status = 1;

  optional string phase = 2;

  optional string message = 3;

  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastUpdated = 4;

  optional uint32 vertexCount = 5;

  optional uint32 sourceCount = 6;

  optional uint32 sinkCount = 7;

  optional uint32 udfCount = 8;
}

message RedisBufferService {
  // Native brings up a native Redis service
  optional NativeRedis native = 1;

  // External holds an External Redis config
  optional RedisConfig external = 2;
}

message RedisConfig {
  // Redis URL
  // +optional
  optional string url = 1;

  // Sentinel URL, will be ignored if Redis URL is provided
  // +optional
  optional string sentinelUrl = 2;

  // Only required when Sentinel is used
  // +optional
  optional string masterName = 3;

  // Redis user
  // +optional
  optional string user = 4;

  // Redis password secret selector
  // +optional
  optional k8s.io.api.core.v1.SecretKeySelector password = 5;

  // Sentinel password secret selector
  // +optional
  optional k8s.io.api.core.v1.SecretKeySelector sentinelPassword = 6;
}

message RedisSettings {
  // Redis settings shared by both master and slaves, will override the global settings from controller config
  // +optional
  optional string redis = 1;

  // Special settings for Redis master node, will override the global settings from controller config
  // +optional
  optional string master = 2;

  // Special settings for Redis replica nodes, will override the global settings from controller config
  // +optional
  optional string replica = 3;

  // Sentinel settings, will override the global settings from controller config
  // +optional
  optional string sentinel = 4;
}

message SASL {
  // SASL mechanism to use
  optional string mechanism = 1;

  // GSSAPI contains the kerberos config
  // +optional
  optional GSSAPI gssapi = 2;

  // SASLPlain contains the sasl plain config
  // +optional
  optional SASLPlain plain = 3;

  // SASLSCRAMSHA256 contains the sasl plain config
  // +optional
  optional SASLPlain scramsha256 = 4;

  // SASLSCRAMSHA512 contains the sasl plain config
  // +optional
  optional SASLPlain scramsha512 = 5;
}

message SASLPlain {
  // UserSecret refers to the secret that contains the user
  optional k8s.io.api.core.v1.SecretKeySelector userSecret = 1;

  // PasswordSecret refers to the secret that contains the password
  // +optional
  optional k8s.io.api.core.v1.SecretKeySelector passwordSecret = 2;

  optional bool handshake = 3;
}

// Scale defines the parameters for autoscaling.
message Scale {
  // Whether to disable autoscaling.
  // Set to "true" when using Kubernetes HPA or any other 3rd party autoscaling strategies.
  // +optional
  optional bool disabled = 1;

  // Minimum replicas.
  // +optional
  optional int32 min = 2;

  // Maximum replicas.
  // +optional
  optional int32 max = 3;

  // Lookback seconds to calculate the average pending messages and processing rate.
  // +optional
  optional uint32 lookbackSeconds = 4;

  // Deprecated: Use scaleUpCooldownSeconds and scaleDownCooldownSeconds instead.
  // Cooldown seconds after a scaling operation before another one.
  // +optional
  optional uint32 cooldownSeconds = 5;

  // After scaling down the source vertex to 0, sleep how many seconds before scaling the source vertex back up to peek.
  // +optional
  optional uint32 zeroReplicaSleepSeconds = 6;

  // TargetProcessingSeconds is used to tune the aggressiveness of autoscaling for source vertices, it measures how fast
  // you want the vertex to process all the pending messages. Typically increasing the value, which leads to lower processing
  // rate, thus less replicas. It's only effective for source vertices.
  // +optional
  optional uint32 targetProcessingSeconds = 7;

  // TargetBufferAvailability is used to define the target percentage of the buffer availability.
  // A valid and meaningful value should be less than the BufferUsageLimit defined in the Edge spec (or Pipeline spec), for example, 50.
  // It only applies to UDF and Sink vertices because only they have buffers to read.
  // +optional
  optional uint32 targetBufferAvailability = 8;

  // ReplicasPerScale defines maximum replicas can be scaled up or down at once.
  // The is use to prevent too aggressive scaling operations
  // +optional
  optional uint32 replicasPerScale = 9;

  // ScaleUpCooldownSeconds defines the cooldown seconds after a scaling operation, before a follow-up scaling up.
  // It defaults to the CooldownSeconds if not set.
  // +optional
  optional uint32 scaleUpCooldownSeconds = 10;

  // ScaleDownCooldownSeconds defines the cooldown seconds after a scaling operation, before a follow-up scaling down.
  // It defaults to the CooldownSeconds if not set.
  // +optional
  optional uint32 scaleDownCooldownSeconds = 11;
}

// SessionWindow describes a session window
message SessionWindow {
  // Timeout is the duration of inactivity after which a session window closes.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Duration timeout = 1;
}

// SideInput defines information of a Side Input
message SideInput {
  optional string name = 1;

  optional Container container = 2;

  // +optional
  // +patchStrategy=merge
  // +patchMergeKey=name
  repeated k8s.io.api.core.v1.Volume volumes = 3;

  optional SideInputTrigger trigger = 4;
}

message SideInputTrigger {
  // The schedule to trigger the retrievement of the side input data.
  // It supports cron format, for example, "0 30 * * * *".
  // Or interval based format, such as "@hourly", "@every 1h30m", etc.
  optional string schedule = 1;

  // +optional
  optional string timezone = 2;
}

message SideInputsManagerTemplate {
  // +optional
  optional AbstractPodTemplate abstractPodTemplate = 1;

  // Template for the side inputs manager numa container
  // +optional
  optional ContainerTemplate containerTemplate = 2;

  // Template for the side inputs manager init container
  // +optional
  optional ContainerTemplate initContainerTemplate = 3;
}

message Sink {
  optional Log log = 1;

  optional KafkaSink kafka = 2;

  optional Blackhole blackhole = 3;

  optional UDSink udsink = 4;
}

// SlidingWindow describes a sliding window
message SlidingWindow {
  // Length is the duration of the sliding window.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Duration length = 1;

  // Slide is the slide parameter that controls the frequency at which the sliding window is created.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Duration slide = 2;

  // +optional
  // Streaming should be set to true if the reduce udf is streaming.
  optional bool streaming = 3;
}

message Source {
  // +optional
  optional GeneratorSource generator = 1;

  // +optional
  optional KafkaSource kafka = 2;

  // +optional
  optional HTTPSource http = 3;

  // +optional
  optional NatsSource nats = 4;

  // +optional
  optional UDTransformer transformer = 5;

  // +optional
  optional UDSource udSource = 6;
}

// Status is a common structure which can be used for Status field.
message Status {
  // Conditions are the latest available observations of a resource's current state.
  // +optional
  // +patchMergeKey=type
  // +patchStrategy=merge
  repeated k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 1;
}

message TLS {
  // +optional
  optional bool insecureSkipVerify = 1;

  // CACertSecret refers to the secret that contains the CA cert
  // +optional
  optional k8s.io.api.core.v1.SecretKeySelector caCertSecret = 2;

  // CertSecret refers to the secret that contains the cert
  // +optional
  optional k8s.io.api.core.v1.SecretKeySelector certSecret = 3;

  // KeySecret refers to the secret that contains the key
  // +optional
  optional k8s.io.api.core.v1.SecretKeySelector keySecret = 4;
}

message TagConditions {
  // Operator specifies the type of operation that should be used for conditional forwarding
  // value could be "and", "or", "not"
  // +kubebuilder:validation:Enum=and;or;not
  // +optional
  optional string operator = 1;

  // Values tag values for conditional forwarding
  repeated string values = 2;
}

message Templates {
  // DaemonTemplate is used to customize the Daemon Deployment.
  // +optional
  optional DaemonTemplate daemon = 1;

  // JobTemplate is used to customize Jobs.
  // +optional
  optional JobTemplate job = 2;

  // SideInputsManagerTemplate is used to customize the Side Inputs Manager.
  // +optional
  optional SideInputsManagerTemplate sideInputsManager = 3;

  // VertexTemplate is used to customize the vertices of the pipeline.
  // +optional
  optional VertexTemplate vertex = 4;
}

message Transformer {
  // +kubebuilder:validation:Enum=eventTimeExtractor;filter;timeExtractionFilter
  optional string name = 1;

  // +optional
  repeated string args = 2;

  // +optional
  map<string, string> kwargs = 3;
}

message UDF {
  // +optional
  optional Container container = 1;

  // +optional
  optional Function builtin = 2;

  // +optional
  optional GroupBy groupBy = 3;
}

message UDSink {
  optional Container container = 1;
}

message UDSource {
  optional Container container = 1;
}

message UDTransformer {
  // +optional
  optional Container container = 1;

  // +optional
  optional Transformer builtin = 2;
}

// +genclient
// +kubebuilder:object:root=true
// +kubebuilder:resource:shortName=vtx
// +kubebuilder:subresource:status
// +kubebuilder:subresource:scale:specpath=.spec.replicas,statuspath=.status.replicas,selectorpath=.status.selector
// +kubebuilder:printcolumn:name="Phase",type=string,JSONPath=`.status.phase`
// +kubebuilder:printcolumn:name="Reason",type=string,JSONPath=`.status.reason`
// +kubebuilder:printcolumn:name="Message",type=string,JSONPath=`.status.message`
// +kubebuilder:printcolumn:name="Desired",type=string,JSONPath=`.spec.replicas`
// +kubebuilder:printcolumn:name="Current",type=string,JSONPath=`.status.replicas`
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +k8s:openapi-gen=true
message Vertex {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional VertexSpec spec = 2;

  // +optional
  optional VertexStatus status = 3;
}

// VertexInstance is a wrapper of a vertex instance, which contains the vertex spec and the instance information such as hostname and replica index.
message VertexInstance {
  optional Vertex vertex = 1;

  optional string hostname = 2;

  optional int32 replica = 3;
}

message VertexLimits {
  // Read batch size from the source or buffer.
  // It overrides the settings from pipeline limits.
  // +optional
  optional uint64 readBatchSize = 1;

  // Read timeout duration from the source or buffer
  // It overrides the settings from pipeline limits.
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Duration readTimeout = 2;

  // BufferMaxLength is used to define the max length of a buffer.
  // It overrides the settings from pipeline limits.
  // +optional
  optional uint64 bufferMaxLength = 3;

  // BufferUsageLimit is used to define the percentage of the buffer usage limit, a valid value should be less than 100, for example, 85.
  // It overrides the settings from pipeline limits.
  // +optional
  optional uint32 bufferUsageLimit = 4;

  // RetryInterval is the duration waited for before retrying after a UDF processing or buffer writing.
  // It overrides the settings from the pipeline limits.
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Duration retryInterval = 5;
}

// +kubebuilder:object:root=true
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message VertexList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated Vertex items = 2;
}

message VertexSpec {
  optional AbstractVertex abstractVertex = 1;

  optional string pipelineName = 2;

  // +optional
  optional string interStepBufferServiceName = 3;

  // +kubebuilder:default=1
  // +optional
  optional int32 replicas = 4;

  // +optional
  repeated CombinedEdge fromEdges = 5;

  // +optional
  repeated CombinedEdge toEdges = 6;

  // Watermark indicates watermark progression in the vertex, it's populated from the pipeline watermark settings.
  // +kubebuilder:default={"disabled": false}
  // +optional
  optional Watermark watermark = 7;
}

message VertexStatus {
  optional string phase = 1;

  optional string reason = 6;

  optional string message = 2;

  optional uint32 replicas = 3;

  optional string selector = 5;

  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastScaledAt = 4;
}

message VertexTemplate {
  // +optional
  optional AbstractPodTemplate abstractPodTemplate = 1;

  // Template for the vertex numa container
  // +optional
  optional ContainerTemplate containerTemplate = 2;

  // Template for the vertex init container
  // +optional
  optional ContainerTemplate initContainerTemplate = 3;
}

message Watermark {
  // Disabled toggles the watermark propagation, defaults to false.
  // +kubebuilder:default=false
  // +optional
  optional bool disabled = 1;

  // Maximum delay allowed for watermark calculation, defaults to "0s", which means no delay.
  // +kubebuilder:default="0s"
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Duration maxDelay = 2;

  // IdleSource defines the idle watermark properties, it could be configured in case source is idling.
  // +optional
  optional IdleSource idleSource = 3;
}

// Window describes windowing strategy
message Window {
  // +optional
  optional FixedWindow fixed = 1;

  // +optional
  optional SlidingWindow sliding = 2;

  // +optional
  optional SessionWindow session = 3;
}

