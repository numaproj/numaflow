/*
Copyright 2022 The Numaproj Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/


// This file was autogenerated by go-to-protobuf. Do not edit it manually!

syntax = "proto2";

package github.com.numaproj.numaflow.pkg.apis.numaflow.v1alpha1;

import "k8s.io/api/core/v1/generated.proto";
import "k8s.io/apimachinery/pkg/api/resource/generated.proto";
import "k8s.io/apimachinery/pkg/apis/meta/v1/generated.proto";
import "k8s.io/apimachinery/pkg/runtime/generated.proto";
import "k8s.io/apimachinery/pkg/runtime/schema/generated.proto";
import "k8s.io/apimachinery/pkg/util/intstr/generated.proto";

// Package-wide variables from generator "generated".
option go_package = "github.com/numaproj/numaflow/pkg/apis/numaflow/v1alpha1";

// AWSAssumeRole contains the configuration for AWS STS assume role authentication
// This can be used with any AWS service (SQS, S3, DynamoDB, etc.)
message AWSAssumeRole {
  // RoleARN is the Amazon Resource Name (ARN) of the role to assume.
  // This is a required field when assume role is enabled.
  // Example: "arn:aws:iam::123456789012:role/CrossAccount-Service-Role"
  optional string roleArn = 1;

  // SessionName is an identifier for the assumed role session.
  // This appears in AWS CloudTrail logs to help identify the source of API calls.
  // If not specified, a default session name will be generated based on the service context.
  // +optional
  optional string sessionName = 2;

  // DurationSeconds is the duration (in seconds) of the role session.
  // Valid values: 900-43200 (15 minutes to 12 hours)
  // Defaults to 3600 (1 hour) if not specified.
  // The actual session duration is constrained by the maximum session duration
  // setting of the IAM role being assumed.
  // +optional
  optional int32 durationSeconds = 3;

  // ExternalID is a unique identifier that might be required when you assume a role
  // in another account. This is commonly used as an additional security measure
  // for cross-account role access.
  // +optional
  optional string externalID = 4;

  // Policy is an IAM policy document (JSON string) that you want to use as an inline session policy.
  // This parameter is optional. When specified, the session permissions are the intersection of
  // the IAM role's identity-based policy and the session policies.
  // This allows further restriction of permissions for the specific service operations.
  // +optional
  optional string policy = 5;

  // PolicyARNs is a list of Amazon Resource Names (ARNs) of IAM managed policies
  // that you want to use as managed session policies.
  // The policies must exist in the same account as the role.
  // This allows attaching existing managed policies to further restrict session permissions.
  // +optional
  repeated string policyArns = 6;
}

// AbstractPodTemplate provides a template for pod customization in vertices, daemon deployments and so on.
message AbstractPodTemplate {
  // Metadata sets the pods's metadata, i.e. annotations and labels
  // +optional
  optional Metadata metadata = 1;

  // NodeSelector is a selector which must be true for the pod to fit on a node.
  // Selector which must match a node's labels for the pod to be scheduled on that node.
  // More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
  // +optional
  map<string, string> nodeSelector = 2;

  // If specified, the pod's tolerations.
  // +optional
  repeated .k8s.io.api.core.v1.Toleration tolerations = 3;

  // SecurityContext holds pod-level security attributes and common container settings.
  // Optional: Defaults to empty.  See type description for default values of each field.
  // +optional
  optional .k8s.io.api.core.v1.PodSecurityContext securityContext = 4;

  // ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec.
  // If specified, these secrets will be passed to individual puller implementations for them to use. For example,
  // in the case of docker, only DockerConfig type secrets are honored.
  // More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod
  // +optional
  // +patchMergeKey=name
  // +patchStrategy=merge
  repeated .k8s.io.api.core.v1.LocalObjectReference imagePullSecrets = 5;

  // If specified, indicates the pod's priority. "system-node-critical"
  // and "system-cluster-critical" are two special keywords which indicate the
  // highest priorities with the former being the highest priority. Any other
  // name must be defined by creating a PriorityClass object with that name.
  // If not specified, the pod priority will be default or zero if there is no
  // default.
  // More info: https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/
  // +optional
  optional string priorityClassName = 6;

  // The priority value. Various system components use this field to find the
  // priority of the pod. When Priority Admission Controller is enabled,
  // it prevents users from setting this field. The admission controller populates
  // this field from PriorityClassName.
  // The higher the value, the higher the priority.
  // More info: https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/
  // +optional
  optional int32 priority = 7;

  // The pod's scheduling constraints
  // More info: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/
  // +optional
  optional .k8s.io.api.core.v1.Affinity affinity = 8;

  // ServiceAccountName applied to the pod
  // +optional
  optional string serviceAccountName = 9;

  // RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used
  // to run this pod.  If no RuntimeClass resource matches the named class, the pod will not be run.
  // If unset or empty, the "legacy" RuntimeClass will be used, which is an implicit class with an
  // empty definition that uses the default runtime handler.
  // More info: https://git.k8s.io/enhancements/keps/sig-node/585-runtime-class
  // +optional
  optional string runtimeClassName = 10;

  // AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.
  // +optional
  optional bool automountServiceAccountToken = 11;

  // Set DNS policy for the pod.
  // Defaults to "ClusterFirst".
  // Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'.
  // DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy.
  // To have DNS options set along with hostNetwork, you have to specify DNS policy
  // explicitly to 'ClusterFirstWithHostNet'.
  // +optional
  optional string dnsPolicy = 12;

  // Specifies the DNS parameters of a pod.
  // Parameters specified here will be merged to the generated DNS
  // configuration based on DNSPolicy.
  // +optional
  optional .k8s.io.api.core.v1.PodDNSConfig dnsConfig = 13;

  // ResourceClaims defines which ResourceClaims must be allocated and reserved
  // before the Pod is allowed to start. The resources will be made available to those
  // containers which consume them by name.
  // +patchMergeKey=name
  // +patchStrategy=merge,retainKeys
  // +optional
  repeated .k8s.io.api.core.v1.PodResourceClaim resourceClaims = 14;
}

message AbstractSink {
  // Log sink is used to write the data to the log.
  // +optional
  optional Log log = 1;

  // Kafka sink is used to write the data to the Kafka.
  // +optional
  optional KafkaSink kafka = 2;

  // Blackhole sink is used to write the data to the blackhole sink,
  // which is a sink that discards all the data written to it.
  // +optional
  optional Blackhole blackhole = 3;

  // UDSink sink is used to write the data to the user-defined sink.
  // +optional
  optional UDSink udsink = 4;

  // Serve sink is used to return results when working with a ServingPipeline.
  // +optional
  optional ServeSink serve = 5;

  // SQS sink is used to write the data to the AWS SQS.
  // +optional
  optional SqsSink sqs = 6;

  // Pulsar sink is used to write the data to the Apache Pulsar.
  // +optional
  optional PulsarSink pulsar = 7;
}

message AbstractVertex {
  optional string name = 1;

  // +optional
  optional Source source = 2;

  // +optional
  optional Sink sink = 3;

  // +optional
  optional UDF udf = 4;

  // Container template for the main numa container.
  // +optional
  optional ContainerTemplate containerTemplate = 5;

  // Container template for all the vertex pod init containers spawned by numaflow, excluding the ones specified by the user.
  // +optional
  optional ContainerTemplate initContainerTemplate = 6;

  // +optional
  optional AbstractPodTemplate abstractPodTemplate = 7;

  // +optional
  // +patchStrategy=merge
  // +patchMergeKey=name
  repeated .k8s.io.api.core.v1.Volume volumes = 8;

  // Limits define the limitations such as buffer read batch size for all the vertices of a pipeline, will override pipeline level settings
  // +optional
  optional VertexLimits limits = 9;

  // Settings for autoscaling
  // +optional
  optional Scale scale = 10;

  // List of customized init containers belonging to the pod.
  // More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
  // +optional
  repeated .k8s.io.api.core.v1.Container initContainers = 11;

  // List of customized sidecar containers belonging to the pod.
  // +optional
  repeated .k8s.io.api.core.v1.Container sidecars = 12;

  // Number of partitions of the vertex owned buffers.
  // It applies to udf and sink vertices only.
  // +optional
  optional int32 partitions = 13;

  // Names of the side inputs used in this vertex.
  // +optional
  repeated string sideInputs = 14;

  // Container template for the side inputs watcher container.
  // +optional
  optional ContainerTemplate sideInputsContainerTemplate = 15;

  // The strategy to use to replace existing pods with new ones.
  // +kubebuilder:default={"type": "RollingUpdate", "rollingUpdate": {"maxUnavailable": "25%"}}
  // +optional
  optional UpdateStrategy updateStrategy = 16;
}

// AccumulatorWindow describes a special kind of SessionWindow (similar to Global Window) where output should
// always have monotonically increasing WM but it can be manipulated through event-time by reordering the messages.
// NOTE: Quite powerful, should not be abused; it can cause stalling of pipelines and leaks.
message AccumulatorWindow {
  // Timeout is the duration of inactivity after which the state of the accumulator is removed.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Duration timeout = 1;
}

message Authorization {
  // A secret selector which contains bearer token
  // To use this, the client needs to add "Authorization: Bearer <token>" in the header
  // +optional
  optional .k8s.io.api.core.v1.SecretKeySelector token = 1;
}

// Backoff defines parameters used to systematically configure the retry strategy.
message Backoff {
  // Interval sets the initial retry duration, after a failure occurs.
  // +kubebuilder:default="1ms"
  // +optional
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Duration interval = 1;

  // Steps defines the maximum number of retry attempts
  // +optional
  optional uint32 steps = 2;

  // Interval is multiplied by factor each iteration, if factor is not zero
  // and the limits imposed by Steps and Cap have not been reached.
  // +optional
  optional double factor = 3;

  // A limit on revised values of the interval parameter. If a
  // multiplication by the factor parameter would make the interval
  // exceed the cap then the interval is set to the cap and the
  // steps parameter is set to zero.
  // +optional
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Duration cap = 4;

  // The sleep at each iteration is the interval plus an additional
  // amount chosen uniformly at random from the interval between
  // zero and `jitter*interval`.
  // +optional
  optional double jitter = 5;
}

// BasicAuth represents the basic authentication approach which contains a user name and a password.
message BasicAuth {
  // Secret for auth user
  // +optional
  optional .k8s.io.api.core.v1.SecretKeySelector user = 1;

  // Secret for auth password
  // +optional
  optional .k8s.io.api.core.v1.SecretKeySelector password = 2;
}

// Blackhole is a sink to emulate /dev/null
message Blackhole {
}

message BufferServiceConfig {
  optional JetStreamConfig jetstream = 2;
}

// CombinedEdge is a combination of Edge and some other properties such as vertex type, partitions, limits.
// It's used to decorate the fromEdges and toEdges of the generated Vertex objects, so that in the vertex pod,
// it knows the properties of the connected vertices, for example, how many partitioned buffers I should write
// to, what is the write buffer length, etc.
message CombinedEdge {
  optional Edge edge = 1;

  // From vertex type.
  optional string fromVertexType = 2;

  // The number of partitions of the from vertex, if not provided, the default value is set to "1".
  // +optional
  optional int32 fromVertexPartitionCount = 3;

  // +optional
  optional VertexLimits fromVertexLimits = 4;

  // To vertex type.
  optional string toVertexType = 5;

  // The number of partitions of the to vertex, if not provided, the default value is set to "1".
  // +optional
  optional int32 toVertexPartitionCount = 6;

  // +optional
  optional VertexLimits toVertexLimits = 7;
}

// Compression is the compression settings for the messages in the InterStepBuffer
message Compression {
  // Type is the type of compression to be used
  // +kubebuilder:validation:Enum:None;GZIP;ZSTD;LZ4
  // +kubebuilder:default:=None
  // +optional
  optional string type = 1;
}

// Container is used to define the container properties for user-defined functions, sinks, etc.
message Container {
  // +optional
  optional string image = 1;

  // +optional
  repeated string command = 2;

  // +optional
  repeated string args = 3;

  // +optional
  repeated .k8s.io.api.core.v1.EnvVar env = 4;

  // +optional
  repeated .k8s.io.api.core.v1.EnvFromSource envFrom = 5;

  // +optional
  repeated .k8s.io.api.core.v1.VolumeMount volumeMounts = 6;

  // +optional
  optional .k8s.io.api.core.v1.ResourceRequirements resources = 7;

  // +optional
  optional .k8s.io.api.core.v1.SecurityContext securityContext = 8;

  // +optional
  optional string imagePullPolicy = 9;

  // +optional
  optional Probe readinessProbe = 10;

  // +optional
  optional Probe livenessProbe = 11;

  // +optional
  // +patchMergeKey=containerPort
  // +patchStrategy=merge
  // +listType=map
  // +listMapKey=containerPort
  // +listMapKey=protocol
  repeated .k8s.io.api.core.v1.ContainerPort ports = 12;
}

// ContainerTemplate defines customized spec for a container
message ContainerTemplate {
  // +optional
  optional .k8s.io.api.core.v1.ResourceRequirements resources = 1;

  // +optional
  optional string imagePullPolicy = 2;

  // +optional
  optional .k8s.io.api.core.v1.SecurityContext securityContext = 3;

  // +optional
  repeated .k8s.io.api.core.v1.EnvVar env = 4;

  // +optional
  repeated .k8s.io.api.core.v1.EnvFromSource envFrom = 5;

  // +optional
  optional Probe readinessProbe = 6;

  // +optional
  optional Probe livenessProbe = 7;
}

message DaemonTemplate {
  // +optional
  optional AbstractPodTemplate abstractPodTemplate = 1;

  // Replicas is the number of desired replicas of the Deployment.
  // This is a pointer to distinguish between explicit zero and unspecified.
  // Defaults to 1.
  // More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#what-is-a-replicationcontroller
  // +optional
  optional int32 replicas = 2;

  // +optional
  optional ContainerTemplate containerTemplate = 3;

  // +optional
  optional ContainerTemplate initContainerTemplate = 4;
}

message Edge {
  optional string from = 1;

  optional string to = 2;

  // Conditional forwarding, only allowed when "From" is a Source or UDF.
  // +optional
  optional ForwardConditions conditions = 3;

  // OnFull specifies the behaviour for the write actions when the inter step buffer is full.
  // There are currently two options, retryUntilSuccess and discardLatest.
  // if not provided, the default value is set to "retryUntilSuccess"
  // +kubebuilder:validation:Enum=retryUntilSuccess;discardLatest
  // +optional
  optional string onFull = 4;
}

// FixedWindow describes a fixed window
message FixedWindow {
  // Length is the duration of the fixed window.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Duration length = 1;

  // +optional
  // Streaming should be set to true if the reduce udf is streaming.
  optional bool streaming = 2;
}

message ForwardConditions {
  // Tags used to specify tags for conditional forwarding
  optional TagConditions tags = 1;
}

// GSSAPI represents a SASL GSSAPI config
message GSSAPI {
  optional string serviceName = 1;

  optional string realm = 2;

  // UsernameSecret refers to the secret that contains the username
  optional .k8s.io.api.core.v1.SecretKeySelector usernameSecret = 3;

  // valid inputs - KRB5_USER_AUTH, KRB5_KEYTAB_AUTH
  optional string authType = 4;

  // PasswordSecret refers to the secret that contains the password
  // +optional
  optional .k8s.io.api.core.v1.SecretKeySelector passwordSecret = 5;

  // KeytabSecret refers to the secret that contains the keytab
  // +optional
  optional .k8s.io.api.core.v1.SecretKeySelector keytabSecret = 6;

  // KerberosConfigSecret refers to the secret that contains the kerberos config
  // +optional
  optional .k8s.io.api.core.v1.SecretKeySelector kerberosConfigSecret = 7;
}

message GeneratorSource {
  // +kubebuilder:default=5
  // +optional
  optional int64 rpu = 1;

  // +kubebuilder:default="1s"
  // +optional
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Duration duration = 2;

  // Size of each generated message
  // +kubebuilder:default=8
  // +optional
  optional int32 msgSize = 3;

  // KeyCount is the number of unique keys in the payload
  // +optional
  optional int32 keyCount = 4;

  // Value is an optional uint64 value to be written in to the payload
  // +optional
  optional uint64 value = 5;

  // Jitter is the jitter for the message generation, used to simulate out of order messages
  // for example if the jitter is 10s, then the message's event time will be delayed by a random
  // time between 0 and 10s which will result in the message being out of order by 0 to 10s
  // +kubebuilder:default="0s"
  // +optional
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Duration jitter = 6;

  // ValueBlob is an optional string which is the base64 encoding of direct payload to send.
  // This is useful for attaching a GeneratorSource to a true pipeline to test load behavior
  // with true messages without requiring additional work to generate messages through
  // the external source
  // if present, the Value and MsgSize fields will be ignored.
  // +optional
  optional string valueBlob = 7;
}

message GetDaemonDeploymentReq {
  optional string isbSvcType = 1;

  optional string image = 2;

  optional string pullPolicy = 3;

  repeated .k8s.io.api.core.v1.EnvVar env = 4;

  optional .k8s.io.api.core.v1.ResourceRequirements defaultResources = 5;
}

message GetJetStreamServiceSpecReq {
  map<string, string> labels = 1;

  optional int32 clusterPort = 2;

  optional int32 clientPort = 3;

  optional int32 monitorPort = 4;

  optional int32 metricsPort = 5;
}

message GetJetStreamStatefulSetSpecReq {
  optional string serviceName = 1;

  map<string, string> labels = 2;

  optional string natsImage = 3;

  optional string metricsExporterImage = 4;

  optional string configReloaderImage = 5;

  optional int32 clusterPort = 6;

  optional int32 clientPort = 7;

  optional int32 monitorPort = 8;

  optional int32 metricsPort = 9;

  optional string serverAuthSecretName = 10;

  optional string serverEncryptionSecretName = 11;

  optional string configMapName = 12;

  optional string pvcNameIfNeeded = 13;

  optional string startCommand = 14;

  optional .k8s.io.api.core.v1.ResourceRequirements defaultResources = 15;
}

message GetMonoVertexDaemonDeploymentReq {
  optional string image = 1;

  optional string pullPolicy = 2;

  repeated .k8s.io.api.core.v1.EnvVar env = 3;

  optional .k8s.io.api.core.v1.ResourceRequirements defaultResources = 4;
}

message GetMonoVertexPodSpecReq {
  optional string image = 1;

  optional string pullPolicy = 2;

  repeated .k8s.io.api.core.v1.EnvVar env = 3;

  optional .k8s.io.api.core.v1.ResourceRequirements defaultResources = 4;
}

message GetServingPipelineResourceReq {
  optional BufferServiceConfig isbSvcConfig = 1;

  optional string image = 2;

  optional string pullPolicy = 3;

  repeated .k8s.io.api.core.v1.EnvVar env = 4;

  optional .k8s.io.api.core.v1.ResourceRequirements defaultResources = 5;
}

message GetSideInputDeploymentReq {
  optional string isbSvcType = 1;

  optional string image = 2;

  optional string pullPolicy = 3;

  repeated .k8s.io.api.core.v1.EnvVar env = 4;

  optional .k8s.io.api.core.v1.ResourceRequirements defaultResources = 5;
}

message GetVertexPodSpecReq {
  optional string isbSvcType = 1;

  optional string image = 2;

  optional string pullPolicy = 3;

  repeated .k8s.io.api.core.v1.EnvVar env = 4;

  optional string sideInputsStoreName = 5;

  optional string servingSourceStreamName = 6;

  optional PipelineSpec pipelineSpec = 7;

  optional .k8s.io.api.core.v1.ResourceRequirements defaultResources = 8;
}

// GroupBy indicates it is a reducer UDF
message GroupBy {
  // Window describes the windowing strategy.
  optional Window window = 1;

  // +optional
  optional bool keyed = 2;

  // AllowedLateness allows late data to be included for the Reduce operation as long as the late data is not later
  // than (Watermark - AllowedLateness).
  // +optional
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Duration allowedLateness = 3;

  // Storage is used to define the PBQ storage for a reduce vertex.
  optional PBQStorage storage = 4;
}

message HTTPSource {
  // +optional
  optional Authorization auth = 1;

  // Whether to create a ClusterIP Service
  // +optional
  optional bool service = 2;
}

message IdleSource {
  // Threshold is the duration after which a source is marked as Idle due to lack of data.
  // Ex: If watermark found to be idle after the Threshold duration then the watermark is progressed by `IncrementBy`.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Duration threshold = 1;

  // StepInterval is the duration between the subsequent increment of the watermark as long the source remains Idle.
  // The default value is 0s which means that once we detect idle source, we will be incrementing the watermark by
  // `IncrementBy` for time we detect that we source is empty (in other words, this will be a very frequent update).
  // +kubebuilder:default="0s"
  // +optional
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Duration stepInterval = 2;

  // IncrementBy is the duration to be added to the current watermark to progress the watermark when source is idling.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Duration incrementBy = 3;

  // InitSourceDelay is the duration after which, if source doesn't produce any data, the watermark is initialized
  // with the current wall clock time.
  // +optional
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Duration initSourceDelay = 4;
}

// InterStepBuffer configuration specifically for the pipeline.
message InterStepBuffer {
  // Compression is the compression settings for the InterStepBufferService
  // +optional
  optional Compression compression = 2;
}

// +genclient
// +kubebuilder:object:root=true
// +kubebuilder:resource:shortName=isbsvc
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Type",type=string,JSONPath=`.status.type`
// +kubebuilder:printcolumn:name="Phase",type=string,JSONPath=`.status.phase`
// +kubebuilder:printcolumn:name="Age",type=date,JSONPath=`.metadata.creationTimestamp`
// +kubebuilder:printcolumn:name="Message",type=string,JSONPath=`.status.message`
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +k8s:openapi-gen=true
message InterStepBufferService {
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional InterStepBufferServiceSpec spec = 2;

  // +optional
  optional InterStepBufferServiceStatus status = 3;
}

// InterStepBufferServiceList is the list of InterStepBufferService resources
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message InterStepBufferServiceList {
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated InterStepBufferService items = 2;
}

message InterStepBufferServiceSpec {
  optional JetStreamBufferService jetstream = 2;
}

message InterStepBufferServiceStatus {
  optional Status status = 1;

  optional string phase = 2;

  optional string message = 3;

  optional BufferServiceConfig config = 4;

  optional string type = 5;

  optional int64 observedGeneration = 6;
}

message JetStreamBufferService {
  // JetStream version, such as "2.7.1"
  optional string version = 1;

  // JetStream StatefulSet size
  // +kubebuilder:default=3
  optional int32 replicas = 2;

  // ContainerTemplate contains customized spec for NATS container
  // +optional
  optional ContainerTemplate containerTemplate = 3;

  // ReloaderContainerTemplate contains customized spec for config reloader container
  // +optional
  optional ContainerTemplate reloaderContainerTemplate = 4;

  // MetricsContainerTemplate contains customized spec for metrics container
  // +optional
  optional ContainerTemplate metricsContainerTemplate = 5;

  // +optional
  optional PersistenceStrategy persistence = 6;

  // +optional
  optional AbstractPodTemplate abstractPodTemplate = 7;

  // Nats/JetStream configuration, if not specified, global settings in numaflow-controller-config will be used.
  // See https://docs.nats.io/running-a-nats-service/configuration#limits and https://docs.nats.io/running-a-nats-service/configuration#jetstream.
  // For limits, only "max_payload" is supported for configuration, defaults to 1048576 (1MB), not recommended to use values over 8388608 (8MB) but max_payload can be set up to 67108864 (64MB).
  // For jetstream, only "max_memory_store" and "max_file_store" are supported for configuration, do not set "store_dir" as it has been hardcoded.
  // +optional
  optional string settings = 8;

  // Optional arguments to start nats-server. For example, "-D" to enable debugging output, "-DV" to enable debugging and tracing.
  // Check https://docs.nats.io/ for all the available arguments.
  // +optional
  repeated string startArgs = 9;

  // Optional configuration for the streams, consumers and buckets to be created in this JetStream service, if specified, it will be merged with the default configuration in numaflow-controller-config.
  // It accepts a YAML format configuration, it may include 4 sections, "stream", "consumer", "otBucket" and "procBucket".
  // Available fields under "stream" include "retention" (e.g. interest, limits, workerQueue), "maxMsgs", "maxAge" (e.g. 72h), "replicas" (1, 3, 5), "duplicates" (e.g. 5m).
  // Available fields under "consumer" include "ackWait" (e.g. 60s)
  // Available fields under "otBucket" include "maxValueSize", "history", "ttl" (e.g. 72h), "maxBytes", "replicas" (1, 3, 5).
  // Available fields under "procBucket" include "maxValueSize", "history", "ttl" (e.g. 72h), "maxBytes", "replicas" (1, 3, 5).
  // +optional
  optional string bufferConfig = 10;

  // Whether encrypt the data at rest, defaults to false
  // Enabling encryption might impact the performance, see https://docs.nats.io/running-a-nats-service/nats_admin/jetstream_admin/encryption_at_rest for the detail
  // Toggling the value will impact encrypting/decrypting existing messages.
  // +optional
  optional bool encryption = 11;

  // Whether enable TLS, defaults to false
  // Enabling TLS might impact the performance
  // +optional
  optional bool tls = 12;
}

message JetStreamConfig {
  // JetStream (NATS) URL
  optional string url = 1;

  optional NatsAuth auth = 2;

  // +optional
  optional string streamConfig = 3;

  // TLS enabled or not
  optional bool tlsEnabled = 4;
}

message JetStreamSource {
  // URL to connect to NATS cluster, multiple urls could be separated by comma.
  optional string url = 1;

  // Stream represents the name of the stream.
  optional string stream = 2;

  // Consumer represents the name of the consumer of the stream
  // If not specified, a consumer with name `numaflow-pipeline_name-vertex_name-stream_name` will be created.
  // If a consumer name is specified, a consumer with that name will be created if it doesn't exist on the stream.
  // +optional
  optional string consumer = 3;

  // The point in the stream from which to receive messages.
  // https://docs.nats.io/nats-concepts/jetstream/consumers#deliverpolicy
  // Valid options are: "all", "new", "last", "last_per_subject", "by_start_sequence 42", "by_start_time 1753428483000".
  // The second value to "by_start_time" is unix epoch time in milliseconds.
  // +optional
  optional string deliver_policy = 4;

  // A set of subjects that overlap with the subjects bound to the stream to filter delivery to subscribers.
  // https://docs.nats.io/nats-concepts/jetstream/consumers#filtesubjects
  // +optional
  repeated string filter_subjects = 5;

  // TLS configuration for the nats client.
  // +optional
  optional TLS tls = 6;

  // Auth information
  // +optional
  optional NatsAuth auth = 7;
}

message JobTemplate {
  // +optional
  optional AbstractPodTemplate abstractPodTemplate = 1;

  // +optional
  optional ContainerTemplate containerTemplate = 2;

  // ttlSecondsAfterFinished limits the lifetime of a Job that has finished
  // execution (either Complete or Failed). If this field is set,
  // ttlSecondsAfterFinished after the Job finishes, it is eligible to be
  // automatically deleted. When the Job is being deleted, its lifecycle
  // guarantees (e.g. finalizers) will be honored. If this field is unset,
  // the Job won't be automatically deleted. If this field is set to zero,
  // the Job becomes eligible to be deleted immediately after it finishes.
  // Numaflow defaults to 30
  // +optional
  optional int32 ttlSecondsAfterFinished = 3;

  // Specifies the number of retries before marking this job failed.
  // More info: https://kubernetes.io/docs/concepts/workloads/controllers/job/#pod-backoff-failure-policy
  // Numaflow defaults to 20
  // +optional
  optional int32 backoffLimit = 4;
}

message KafkaSink {
  repeated string brokers = 1;

  optional string topic = 2;

  // SetKey sets the Kafka key to the keys passed in the Message.
  // When the key is null (default), the record is sent randomly to one of the available partitions of the topic.
  // If a key exists, Kafka hashes the key, and the result is used to map the message to a specific partition. This
  // ensures that messages with the same key end up in the same partition.
  // +optional
  optional bool setKey = 3;

  // TLS user to configure TLS connection for kafka broker
  // TLS.enable=true default for TLS.
  // +optional
  optional TLS tls = 4;

  // +optional
  optional string config = 5;

  // SASL user to configure SASL connection for kafka broker
  // SASL.enable=true default for SASL.
  // +optional
  optional SASL sasl = 6;
}

message KafkaSource {
  repeated string brokers = 1;

  optional string topic = 2;

  optional string consumerGroup = 3;

  // TLS user to configure TLS connection for kafka broker
  // TLS.enable=true default for TLS.
  // +optional
  optional TLS tls = 4;

  // +optional
  optional string config = 5;

  // SASL user to configure SASL connection for kafka broker
  // SASL.enable=true default for SASL.
  // +optional
  optional SASL sasl = 6;

  optional string kafkaVersion = 7;
}

message Lifecycle {
  // DeletionGracePeriodSeconds used to delete pipeline gracefully
  // +kubebuilder:default=30
  // +optional
  optional int64 deletionGracePeriodSeconds = 1;

  // DesiredPhase used to bring the pipeline from current phase to desired phase
  // +kubebuilder:default=Running
  // +optional
  optional string desiredPhase = 2;

  // PauseGracePeriodSeconds used to pause pipeline gracefully
  // +kubebuilder:default=30
  // +optional
  optional int64 pauseGracePeriodSeconds = 3;

  // DeleteGracePeriodSeconds used to delete pipeline gracefully
  // +kubebuilder:default=30
  // Deprecated: Use DeletionGracePeriodSeconds instead
  // +optional
  optional int64 deleteGracePeriodSeconds = 4;
}

message Log {
}

message Metadata {
  map<string, string> annotations = 1;

  map<string, string> labels = 2;
}

// +genclient
// +kubebuilder:object:root=true
// +kubebuilder:resource:shortName=mvtx
// +kubebuilder:subresource:status
// +kubebuilder:subresource:scale:specpath=.spec.replicas,statuspath=.status.replicas,selectorpath=.status.selector
// +kubebuilder:printcolumn:name="Phase",type=string,JSONPath=`.status.phase`
// +kubebuilder:printcolumn:name="Desired",type=string,JSONPath=`.status.desiredReplicas`
// +kubebuilder:printcolumn:name="Current",type=string,JSONPath=`.status.replicas`
// +kubebuilder:printcolumn:name="Ready",type=string,JSONPath=`.status.readyReplicas`
// +kubebuilder:printcolumn:name="Age",type=date,JSONPath=`.metadata.creationTimestamp`
// +kubebuilder:printcolumn:name="Reason",type=string,JSONPath=`.status.reason`
// +kubebuilder:printcolumn:name="Message",type=string,JSONPath=`.status.message`
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +k8s:openapi-gen=true
message MonoVertex {
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional MonoVertexSpec spec = 2;

  // +optional
  optional MonoVertexStatus status = 3;
}

message MonoVertexLifecycle {
  // DesiredPhase used to bring the MonoVertex from current phase to desired phase
  // +kubebuilder:default=Running
  // +optional
  optional string desiredPhase = 1;
}

message MonoVertexLimits {
  // Read batch size from the source.
  // +kubebuilder:default=500
  // +optional
  optional uint64 readBatchSize = 1;

  // ReadTimeout is the read timeout duration from the source.
  // +kubebuilder:default= "1s"
  // +optional
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Duration readTimeout = 2;

  // RateLimit for MonoVertex defines how many messages can be read from Source. This is computed by number of
  // `read` calls per second multiplied by the `readBatchSize`. This is how RateLimit is calculated for MonoVertex and
  // for Source vertices.
  // +optional
  optional RateLimit rateLimit = 3;
}

// +kubebuilder:object:root=true
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message MonoVertexList {
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated MonoVertex items = 2;
}

message MonoVertexSpec {
  // +kubebuilder:default=1
  // +optional
  optional int32 replicas = 1;

  optional Source source = 2;

  optional Sink sink = 3;

  // +optional
  optional UDF udf = 4;

  // +optional
  optional AbstractPodTemplate abstractPodTemplate = 5;

  // Container template for the main numa container.
  // +optional
  optional ContainerTemplate containerTemplate = 6;

  // +optional
  // +patchStrategy=merge
  // +patchMergeKey=name
  repeated .k8s.io.api.core.v1.Volume volumes = 7;

  // Limits define the limitations such as read batch size for the mono vertex.
  // +optional
  optional MonoVertexLimits limits = 8;

  // Settings for autoscaling
  // +optional
  optional Scale scale = 9;

  // List of customized init containers belonging to the pod.
  // More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
  // +optional
  repeated .k8s.io.api.core.v1.Container initContainers = 10;

  // List of customized sidecar containers belonging to the pod.
  // +optional
  repeated .k8s.io.api.core.v1.Container sidecars = 11;

  // Template for the daemon service deployment.
  // +optional
  optional DaemonTemplate daemonTemplate = 12;

  // The strategy to use to replace existing pods with new ones.
  // +kubebuilder:default={"type": "RollingUpdate", "rollingUpdate": {"maxUnavailable": "25%"}}
  // +optional
  optional UpdateStrategy updateStrategy = 13;

  // Lifecycle defines the Lifecycle properties of a MonoVertex
  // +kubebuilder:default={"desiredPhase": Running}
  // +optional
  optional MonoVertexLifecycle lifecycle = 14;
}

message MonoVertexStatus {
  optional Status status = 1;

  // +optional
  optional string phase = 2;

  // Total number of non-terminated pods targeted by this MonoVertex (their labels match the selector).
  // +optional
  optional uint32 replicas = 3;

  // The number of desired replicas.
  // +optional
  optional uint32 desiredReplicas = 4;

  // +optional
  optional string selector = 5;

  // +optional
  optional string reason = 6;

  // +optional
  optional string message = 7;

  // +optional
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastUpdated = 8;

  // Time of last scaling operation.
  // +optional
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastScaledAt = 9;

  // The generation observed by the MonoVertex controller.
  // +optional
  optional int64 observedGeneration = 10;

  // The number of pods targeted by this MonoVertex with a Ready Condition.
  // +optional
  optional uint32 readyReplicas = 11;

  // The number of Pods created by the controller from the MonoVertex version indicated by updateHash.
  optional uint32 updatedReplicas = 12;

  // The number of ready Pods created by the controller from the MonoVertex version indicated by updateHash.
  optional uint32 updatedReadyReplicas = 13;

  // If not empty, indicates the current version of the MonoVertex used to generate Pods.
  optional string currentHash = 14;

  // If not empty, indicates the updated version of the MonoVertex used to generate Pods.
  optional string updateHash = 15;
}

// NatsAuth defines how to authenticate the nats access
message NatsAuth {
  // Basic auth which contains a username and a password
  // +optional
  optional BasicAuth basic = 1;

  // Token auth
  // +optional
  optional .k8s.io.api.core.v1.SecretKeySelector token = 2;

  // NKey auth
  // +optional
  optional .k8s.io.api.core.v1.SecretKeySelector nkey = 3;
}

message NatsSource {
  // URL to connect to NATS cluster, multiple urls could be separated by comma.
  optional string url = 1;

  // Subject holds the name of the subject onto which messages are published.
  optional string subject = 2;

  // Queue is used for queue subscription.
  optional string queue = 3;

  // TLS configuration for the nats client.
  // +optional
  optional TLS tls = 4;

  // Auth information
  // +optional
  optional NatsAuth auth = 5;
}

// NoStore means there will be no persistence storage and there will be data loss during pod restarts.
// Use this option only if you do not care about correctness (e.g., approx statistics pipeline like sampling rate, etc.).
message NoStore {
}

// PBQStorage defines the persistence configuration for a vertex.
message PBQStorage {
  // +optional
  optional PersistenceStrategy persistentVolumeClaim = 1;

  // +optional
  optional .k8s.io.api.core.v1.EmptyDirVolumeSource emptyDir = 2;

  // +optional
  optional NoStore no_store = 3;
}

// PersistenceStrategy defines the strategy of persistence
message PersistenceStrategy {
  // Name of the StorageClass required by the claim.
  // More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
  // +optional
  optional string storageClassName = 1;

  // Available access modes such as ReadWriteOncePod, ReadWriteOnce, ReadWriteMany
  // https://kubernetes.io/docs/concepts/storage/persistent-volumes/#access-modes
  // +optional
  optional string accessMode = 2;

  // Volume size, e.g. 50Gi
  optional .k8s.io.apimachinery.pkg.api.resource.Quantity volumeSize = 3;
}

// +genclient
// +kubebuilder:object:root=true
// +kubebuilder:resource:shortName=pl
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Phase",type=string,JSONPath=`.status.phase`
// +kubebuilder:printcolumn:name="Vertices",type=integer,JSONPath=`.status.vertexCount`
// +kubebuilder:printcolumn:name="Sources",type=integer,JSONPath=`.status.sourceCount`,priority=10
// +kubebuilder:printcolumn:name="Sinks",type=integer,JSONPath=`.status.sinkCount`,priority=10
// +kubebuilder:printcolumn:name="UDFs",type=integer,JSONPath=`.status.udfCount`,priority=10
// +kubebuilder:printcolumn:name="Map UDFs",type=integer,JSONPath=`.status.mapUDFCount`,priority=10
// +kubebuilder:printcolumn:name="Reduce UDFs",type=integer,JSONPath=`.status.reduceUDFCount`,priority=10
// +kubebuilder:printcolumn:name="Age",type=date,JSONPath=`.metadata.creationTimestamp`
// +kubebuilder:printcolumn:name="Message",type=string,JSONPath=`.status.message`
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +k8s:openapi-gen=true
message Pipeline {
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional PipelineSpec spec = 2;

  // +optional
  optional PipelineStatus status = 3;
}

message PipelineLimits {
  // Read batch size for all the vertices in the pipeline, can be overridden by the vertex's limit settings.
  // +kubebuilder:default=500
  // +optional
  optional uint64 readBatchSize = 1;

  // BufferMaxLength is used to define the max length of a buffer.
  // Only applies to UDF and Source vertices as only they do buffer write.
  // It can be overridden by the settings in vertex limits.
  // +kubebuilder:default=30000
  // +optional
  optional uint64 bufferMaxLength = 2;

  // BufferUsageLimit is used to define the percentage of the buffer usage limit, a valid value should be less than 100, for example, 85.
  // Only applies to UDF and Source vertices as only they do buffer write.
  // It will be overridden by the settings in vertex limits.
  // +kubebuilder:default=80
  // +optional
  optional uint32 bufferUsageLimit = 3;

  // Read timeout for all the vertices in the pipeline, can be overridden by the vertex's limit settings
  // +kubebuilder:default= "1s"
  // +optional
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Duration readTimeout = 4;

  // RateLimit is used to define the rate limit for all the vertices in the pipeline, it could be overridden by the
  // vertex's limit settings. For source vertices, it will be set to rate divided by readBatchSize because for source
  // vertices, the rate limit is defined by how many times the `Read` is called per second
  // Reduce does not support RateLimit.
  // +optional
  optional RateLimit rateLimit = 5;
}

// +kubebuilder:object:root=true
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message PipelineList {
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated Pipeline items = 2;
}

message PipelineSpec {
  // InterStepBufferServiceName is the name of the InterStepBufferService to be used by the pipeline
  // +optional
  optional string interStepBufferServiceName = 1;

  // +patchStrategy=merge
  // +patchMergeKey=name
  repeated AbstractVertex vertices = 2;

  // Edges define the relationships between vertices
  repeated Edge edges = 3;

  // Lifecycle define the Lifecycle properties
  // +kubebuilder:default={"deleteGracePeriodSeconds": 30, "desiredPhase": Running, "pauseGracePeriodSeconds": 30}
  // +optional
  optional Lifecycle lifecycle = 4;

  // Limits define the limitations such as buffer read batch size for all the vertices of a pipeline, they could be overridden by each vertex's settings
  // +kubebuilder:default={"readBatchSize": 500, "bufferMaxLength": 30000, "bufferUsageLimit": 80}
  // +optional
  optional PipelineLimits limits = 5;

  // Watermark enables watermark progression across the entire pipeline.
  // +kubebuilder:default={"disabled": false}
  // +optional
  optional Watermark watermark = 6;

  // Templates are used to customize additional kubernetes resources required for the Pipeline
  // +optional
  optional Templates templates = 7;

  // SideInputs defines the Side Inputs of a pipeline.
  // +optional
  repeated SideInput sideInputs = 8;

  // InterStepBuffer configuration specific to this pipeline.
  // +optional
  optional InterStepBuffer interStepBuffer = 9;
}

message PipelineStatus {
  optional Status status = 1;

  // +optional
  optional string phase = 2;

  // +optional
  optional string message = 3;

  // +optional
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastUpdated = 4;

  // +optional
  optional uint32 vertexCount = 5;

  // +optional
  optional uint32 sourceCount = 6;

  // +optional
  optional uint32 sinkCount = 7;

  // +optional
  optional uint32 udfCount = 8;

  // +optional
  optional uint32 mapUDFCount = 9;

  // +optional
  optional uint32 reduceUDFCount = 10;

  // The generation observed by the Pipeline controller.
  // +optional
  optional int64 observedGeneration = 11;

  // Field to indicate if a pipeline drain successfully occurred, only meaningful when the pipeline is paused.
  // True means it has been successfully drained.
  // +optional
  optional bool drainedOnPause = 12;
}

message Ports {
  // +optional
  optional int32 https = 1;

  // +optional
  optional int32 http = 2;
}

// Probe is used to customize the configuration for Readiness and Liveness probes.
message Probe {
  // Number of seconds after the container has started before liveness probes are initiated.
  // More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
  // +optional
  optional int32 initialDelaySeconds = 1;

  // Number of seconds after which the probe times out.
  // More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
  // +optional
  optional int32 timeoutSeconds = 2;

  // How often (in seconds) to perform the probe.
  // +optional
  optional int32 periodSeconds = 3;

  // Minimum consecutive successes for the probe to be considered successful after having failed.
  // Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
  // +optional
  optional int32 successThreshold = 4;

  // Minimum consecutive failures for the probe to be considered failed after having succeeded.
  // Defaults to 3. Minimum value is 1.
  // +optional
  optional int32 failureThreshold = 5;
}

// PulsarAuth defines how to authenticate with Pulsar
message PulsarAuth {
  // JWT Token auth
  // +optional
  optional .k8s.io.api.core.v1.SecretKeySelector token = 1;

  // Authentication using HTTP basic https://pulsar.apache.org/docs/4.0.x/security-basic-auth/
  // +optional
  optional PulsarBasicAuth basicAuth = 2;
}

message PulsarBasicAuth {
  // +optional
  optional .k8s.io.api.core.v1.SecretKeySelector username = 1;

  // +optional
  optional .k8s.io.api.core.v1.SecretKeySelector password = 2;
}

message PulsarSink {
  optional string serverAddr = 1;

  optional string topic = 2;

  optional string producerName = 3;

  // Auth information
  // +optional
  optional PulsarAuth auth = 6;
}

message PulsarSource {
  optional string serverAddr = 1;

  optional string topic = 2;

  optional string consumerName = 3;

  optional string subscriptionName = 4;

  // Maximum number of messages that are in not yet acked state. Once this limit is crossed, futher read requests will return empty list.
  optional uint32 maxUnack = 5;

  // Auth information
  // +optional
  optional PulsarAuth auth = 6;
}

message RateLimit {
  // Max is the maximum TPS that this vertex can process give a distributed `Store` is configured. Otherwise, it will
  // be the maximum TPS for a single replica.
  optional uint64 max = 1;

  // Minimum TPS allowed during initial bootup. This value will be distributed across all the replicas if a distributed
  // `Store` is configured. Otherwise, it will be the minimum TPS for a single replica.
  // +kubebuilder:default=1
  optional uint64 min = 2;

  // RampUpDuration is the duration to reach the maximum TPS from the minimum TPS. The min unit of ramp up is 1 in
  // 1 second.
  // +kubebuilder:default= "1s"
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Duration rampUpDuration = 3;

  // Store is used to define the Distributed Store for the rate limiting. We also support in-memory store if no store
  // is configured. This means that every replica will have its own rate limit and the actual TPS will be the sum of all
  // the replicas.
  // +optional
  optional RateLimiterStore store = 4;

  // RateLimiterModes is used to define the modes for rate limiting.
  // +optional
  optional RateLimiterModes modes = 5;

  // ResumedRampUp is used to enable the resume mode for rate limiting.
  //
  // This, if true, will allow the processor to
  // resume the ramp-up process from the last known state of the rate limiter, i.e., if the processor was allowed X tokens
  // before shutting down, it will be allowed X tokens again after the processor restarts.
  //
  // The resumed ramp-up process will be allowed until TTL time after the processor first deregisters with the rate limiter.
  // +optional
  // +kubebuilder:default=false
  optional bool resumedRampUp = 6;

  // TTL is used to define the duration after which a pod is considered stale and removed from the pool of pods if it
  // doesn't sync with the rate limiter.
  //
  // Furthermore, if the ResumedRampUp is true, then TTL also defines the amount of time within which, if a pod
  // re-registers / registers with the same name, with the rate limiter, it will be assigned the same rate limit as
  // the previous pod with that name.
  // +optional
  // +kubebuilder:default="180s"
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Duration ttl = 7;
}

// RateLimiterGoBackN is for the GoBackN mode.
// Releases additional tokens only when previously released tokens have been utilized above the configured threshold
// otherwise triggers a ramp-down. Ramp-down is also triggered when the request is made after quite a while.
message RateLimiterGoBackN {
  // CoolDownPeriod is the duration after which the rate limiter will start ramping down if the request is made after
  // the cool-down period.
  // +optional
  // +kubebuilder:default="5s"
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Duration coolDownPeriod = 1;

  // RampDownStrength is the strength of the ramp-down. It is a value between 0 and 1. 0 means no ramp-down and 1 means
  // token pool is ramped down at the rate of slope=(max - min)/duration.
  // +optional
  // +kubebuilder:default=50
  optional uint32 rampDownPercentage = 2;

  // ThresholdPercentage specifies the minimum percentage of capacity, availed by the rate limiter,
  // that should be consumed at any instance to allow the rate limiter to unlock additional capacity.
  // For example, given the following configuration:
  // - max = 100
  // - min = 10
  // - rampUpDuration = 10s i.e.--> slope = 10 messages/second
  // - thresholdPercentage = 50
  // at t = 0, the rate limiter will release 10 messages and at least 5 of those should be consumed to unlock
  // additional capacity of 10 messages at t = 1 to make the total capacity of 20.
  // +optional
  // +kubebuilder:default=50
  optional uint32 thresholdPercentage = 3;
}

message RateLimiterInMemoryStore {
}

// RateLimiterModes defines the modes for rate limiting.
message RateLimiterModes {
  // Irrespective of the traffic, the rate limiter releases max possible tokens based on ramp-up duration.
  // +optional
  optional RateLimiterScheduled scheduled = 2;

  // If there is some traffic, then release the max possible tokens.
  // +optional
  optional RateLimiterRelaxed relaxed = 1;

  // Releases additional tokens only when previously released tokens have been utilized above the configured threshold
  // +optional
  optional RateLimiterOnlyIfUsed onlyIfUsed = 3;

  // Releases additional tokens only when previously released tokens have been utilized above the configured threshold
  // otherwise triggers a ramp-down. Ramp-down is also triggered when the request is made after quite a while.
  // +optional
  optional RateLimiterGoBackN goBackN = 4;
}

// RateLimiterOnlyIfUsed is for the OnlyIfUsed mode.
// Releases additional tokens only when previously released tokens have been utilized above the configured threshold
message RateLimiterOnlyIfUsed {
  // ThresholdPercentage specifies the minimum percentage of capacity, availed by the rate limiter,
  // that should be consumed at any instance to allow the rate limiter to unlock additional capacity.
  //
  // Defaults to 50%
  //
  // For example, given the following configuration:
  // - max = 100
  // - min = 10
  // - rampUpDuration = 10s i.e.--> slope = 10 messages/second
  // - thresholdPercentage = 50
  // at t = 0, the rate limiter will release 10 messages and at least 5 of those should be consumed to unlock
  // additional capacity of 10 messages at t = 1 to make the total capacity of 20.
  // +optional
  // +kubebuilder:default=50
  optional uint32 thresholdPercentage = 1;
}

message RateLimiterRedisStore {
  // Choose how to connect to Redis.
  // - Single: use a single URL (redis://... or rediss://...)
  // - Sentinel: discover the node via Redis Sentinel
  // +kubebuilder:validation:Enum=single;sentinel
  optional string mode = 1;

  // SINGLE MODE: Full connection URL, e.g. redis://host:6379/0 or rediss://host:port/0
  // Mutually exclusive with .sentinel
  // +optional
  optional string url = 2;

  // SENTINEL MODE: Settings to reach Sentinel and the selected Redis node
  // Mutually exclusive with .url
  // +optional
  optional RedisSentinelConfig sentinel = 3;

  // COMMON: Optional DB index (default 0)
  // +optional
  // +kubebuilder:default=0
  optional int32 db = 4;
}

// RateLimiterRelaxed is for the relaxed mode. It will release the max possible tokens if there is some traffic.
message RateLimiterRelaxed {
}

// RateLimiterScheduled is for the scheduled mode.
// It will release the max possible tokens based on ramp-up duration irrespective of traffic encountered.
message RateLimiterScheduled {
}

message RateLimiterStore {
  // RedisStore is used to define the redis store for the rate limit.
  // +optional
  optional RateLimiterRedisStore redisStore = 1;

  // InMemoryStore is used to define the in-memory store for the rate limit.
  // +optional
  optional RateLimiterInMemoryStore inMemoryStore = 2;
}

message RedisAuth {
  // For Redis 6+ ACLs. If Username omitted, password-only is also supported.
  // +optional
  optional .k8s.io.api.core.v1.SecretKeySelector username = 1;

  // +optional
  optional .k8s.io.api.core.v1.SecretKeySelector password = 2;
}

message RedisSentinelConfig {
  // Required Sentinel "service name" (aka master name) from sentinel.conf
  // +kubebuilder:validation:MinLength=1
  optional string masterName = 1;

  // At least one Sentinel endpoint; 23 recommended. Use host:port pairs.
  // Example: ["sentinel-0.redis.svc:26379", "sentinel-1.redis.svc:26379"]
  // +kubebuilder:validation:MinItems=1
  repeated string endpoints = 2;

  // Auth to talk to the Sentinel daemons (control-plane). Optional.
  // +optional
  optional RedisAuth sentinelAuth = 4;

  // Auth to talk to the Redis data nodes (data-plane). Optional.
  // +optional
  optional RedisAuth redisAuth = 5;

  // TLS for Sentinel connections (if your Sentinels expose TLS).
  // +optional
  optional TLS sentinelTLS = 6;

  // TLS for Redis data nodes (redis). Often enabled even if Sentinel is plaintext.
  // +optional
  optional TLS redisTLS = 7;
}

// The RetryStrategy struct defines the configuration for handling operation retries in case of failures.
// It incorporates an Exponential BackOff strategy to control retry timing and specifies the actions to take upon failure.
message RetryStrategy {
  // BackOff specifies the parameters for the exponential backoff strategy, controlling how delays between retries should increase.
  // +optional
  optional Backoff backoff = 1;

  // OnFailure specifies the action to take when the specified retry strategy fails.
  // The possible values are:
  // 1. "retry": start another round of retrying the operation,
  // 2. "fallback": re-route the operation to a fallback sink and
  // 3. "drop": drop the operation and perform no further action.
  // The default action is to retry.
  // +optional
  // +kubebuilder:default="retry"
  optional string onFailure = 2;
}

// RollingUpdateStrategy is used to communicate parameter for RollingUpdateStrategyType.
message RollingUpdateStrategy {
  // The maximum number of pods that can be unavailable during the update.
  // Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
  // Absolute number is calculated from percentage by rounding down.
  // Defaults to 25%.
  // Example: when this is set to 30%, the old pods can be scaled down to 70% of desired pods
  // immediately when the rolling update starts. Once new pods are ready, old pods
  // can be scaled down further, followed by scaling up the new pods, ensuring
  // that the total number of pods available at all times during the update is at
  // least 70% of desired pods.
  // +optional
  optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;
}

message SASL {
  // SASL mechanism to use
  optional string mechanism = 1;

  // GSSAPI contains the kerberos config
  // +optional
  optional GSSAPI gssapi = 2;

  // SASLPlain contains the sasl plain config
  // +optional
  optional SASLPlain plain = 3;

  // SASLSCRAMSHA256 contains the sasl plain config
  // +optional
  optional SASLPlain scramsha256 = 4;

  // SASLSCRAMSHA512 contains the sasl plain config
  // +optional
  optional SASLPlain scramsha512 = 5;

  // OAuth contains the oauth config
  // +optional
  optional SASLOAuth oauth = 6;
}

message SASLOAuth {
  // ClientID refers to the secret that contains the client id
  optional .k8s.io.api.core.v1.SecretKeySelector clientID = 1;

  // ClientSecret refers to the secret that contains the client secret
  optional .k8s.io.api.core.v1.SecretKeySelector clientSecret = 2;

  // TokenEndpoint refers to the token endpoint
  optional string tokenEndpoint = 3;
}

message SASLPlain {
  // UserSecret refers to the secret that contains the user
  optional .k8s.io.api.core.v1.SecretKeySelector userSecret = 1;

  // PasswordSecret refers to the secret that contains the password
  // +optional
  optional .k8s.io.api.core.v1.SecretKeySelector passwordSecret = 2;

  optional bool handshake = 3;
}

// Scale defines the parameters for autoscaling.
message Scale {
  // Whether to disable autoscaling.
  // Set to "true" when using Kubernetes HPA or any other 3rd party autoscaling strategies.
  // +optional
  optional bool disabled = 1;

  // Minimum replicas.
  // +optional
  optional int32 min = 2;

  // Maximum replicas.
  // +optional
  optional int32 max = 3;

  // Lookback seconds to calculate the average pending messages and processing rate.
  // +optional
  optional uint32 lookbackSeconds = 4;

  // After scaling down the source vertex to 0, sleep how many seconds before scaling the source vertex back up to peek.
  // +optional
  optional uint32 zeroReplicaSleepSeconds = 5;

  // TargetProcessingSeconds is used to tune the aggressiveness of autoscaling for source vertices, it measures how fast
  // you want the vertex to process all the pending messages. Typically increasing the value, which leads to lower processing
  // rate, thus less replicas. It's only effective for source vertices.
  // +optional
  optional uint32 targetProcessingSeconds = 6;

  // TargetBufferAvailability is used to define the target percentage of the buffer availability.
  // A valid and meaningful value should be less than the BufferUsageLimit defined in the Edge spec (or Pipeline spec), for example, 50.
  // It only applies to UDF and Sink vertices because only they have buffers to read.
  // +optional
  optional uint32 targetBufferAvailability = 7;

  // DeprecatedReplicasPerScale defines the number of maximum replicas that can be changed in a single scale up or down operation.
  // The is use to prevent from too aggressive scaling operations
  // Deprecated: Use ReplicasPerScaleUp and ReplicasPerScaleDown instead
  // +optional
  optional uint32 replicasPerScale = 8;

  // ScaleUpCooldownSeconds defines the cooldown seconds after a scaling operation, before a follow-up scaling up.
  // It defaults to the CooldownSeconds if not set.
  // +optional
  optional uint32 scaleUpCooldownSeconds = 9;

  // ScaleDownCooldownSeconds defines the cooldown seconds after a scaling operation, before a follow-up scaling down.
  // It defaults to the CooldownSeconds if not set.
  // +optional
  optional uint32 scaleDownCooldownSeconds = 10;

  // ReplicasPerScaleUp defines the number of maximum replicas that can be changed in a single scaled up operation.
  // The is use to prevent from too aggressive scaling up operations
  // +optional
  optional uint32 replicasPerScaleUp = 11;

  // ReplicasPerScaleDown defines the number of maximum replicas that can be changed in a single scaled down operation.
  // The is use to prevent from too aggressive scaling down operations
  // +optional
  optional uint32 replicasPerScaleDown = 12;
}

message ServeSink {
}

// +genclient
// +kubebuilder:object:root=true
// +kubebuilder:resource:shortName=spl
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Phase",type=string,JSONPath=`.status.phase`
// +kubebuilder:printcolumn:name="Age",type=date,JSONPath=`.metadata.creationTimestamp`
// +kubebuilder:printcolumn:name="Message",type=string,JSONPath=`.status.message`
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +k8s:openapi-gen=true
message ServingPipeline {
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional ServingPipelineSpec spec = 2;

  // +optional
  optional ServingPipelineStatus status = 3;
}

// +kubebuilder:object:root=true
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message ServingPipelineList {
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated ServingPipeline items = 2;
}

message ServingPipelineSpec {
  optional ServingSpec serving = 1;

  optional PipelineSpec pipeline = 2;
}

message ServingPipelineStatus {
  optional Status status = 1;

  // +optional
  optional string phase = 2;

  // +optional
  optional string message = 3;

  // +optional
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastUpdated = 4;

  // The generation observed by the ServingPipeline controller.
  // +optional
  optional int64 observedGeneration = 11;
}

// ServingSource is the source vertex for ServingPipeline and should be used only with ServingPipeline.
message ServingSource {
}

message ServingSpec {
  // +optional
  optional Authorization auth = 1;

  // Whether to create a ClusterIP Service
  // +optional
  optional bool service = 2;

  // Ports to listen on, default we will use 8443 for HTTPS. To start http server
  // the http port should be explicitly set.
  // +optional
  optional Ports ports = 3;

  // The header key from which the message id will be extracted
  optional string msgIDHeaderKey = 4;

  // Request timeout in seconds. Default value is 120 seconds.
  // +optional
  optional uint32 requestTimeoutSeconds = 5;

  // +optional
  optional ServingStore store = 6;

  // Container template for the serving container.
  // +optional
  optional ContainerTemplate containerTemplate = 7;

  // Initial replicas of the serving server deployment.
  // +optional
  optional int32 replicas = 8;

  // +optional
  optional AbstractPodTemplate abstractPodTemplate = 9;
}

// ServingStore defines information of a Serving Store used in a pipeline
message ServingStore {
  optional Container container = 1;
}

// SessionWindow describes a session window
message SessionWindow {
  // Timeout is the duration of inactivity after which a session window closes.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Duration timeout = 1;
}

// SideInput defines information of a Side Input
message SideInput {
  optional string name = 1;

  optional Container container = 2;

  // +optional
  // +patchStrategy=merge
  // +patchMergeKey=name
  repeated .k8s.io.api.core.v1.Volume volumes = 3;

  optional SideInputTrigger trigger = 4;
}

message SideInputTrigger {
  // The schedule to trigger the retrievement of the side input data.
  // It supports cron format, for example, "0 30 * * * *".
  // Or interval based format, such as "@hourly", "@every 1h30m", etc.
  optional string schedule = 1;

  // +optional
  optional string timezone = 2;
}

message SideInputsManagerTemplate {
  // +optional
  optional AbstractPodTemplate abstractPodTemplate = 1;

  // Template for the side inputs manager numa container
  // +optional
  optional ContainerTemplate containerTemplate = 2;

  // Template for the side inputs manager init container
  // +optional
  optional ContainerTemplate initContainerTemplate = 3;
}

message Sink {
  optional AbstractSink abstractSink = 1;

  // Fallback sink can be imagined as DLQ for primary Sink. The writes to Fallback sink will only be
  // initiated if the ud-sink response field sets it.
  // +optional
  optional AbstractSink fallback = 2;

  // OnSuccess sink allows triggering a secondary sink operation only after the primary sink completes successfully
  // The writes to OnSuccess sink will only be initiated if the ud-sink response field sets it.
  // A new Message crafted in the Primary sink can be written on the OnSuccess sink.
  // +optional
  optional AbstractSink onSuccess = 3;

  // RetryStrategy struct encapsulates the settings for retrying operations in the event of failures.
  // +optional
  optional RetryStrategy retryStrategy = 4;
}

// SlidingWindow describes a sliding window
message SlidingWindow {
  // Length is the duration of the sliding window.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Duration length = 1;

  // Slide is the slide parameter that controls the frequency at which the sliding window is created.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Duration slide = 2;

  // +optional
  // Streaming should be set to true if the reduce udf is streaming.
  optional bool streaming = 3;
}

message Source {
  // +optional
  optional GeneratorSource generator = 1;

  // +optional
  optional KafkaSource kafka = 2;

  // +optional
  optional HTTPSource http = 3;

  // +optional
  optional NatsSource nats = 4;

  // +optional
  optional UDTransformer transformer = 5;

  // +optional
  optional UDSource udSource = 6;

  // +optional
  optional JetStreamSource jetstream = 7;

  // +optional
  optional ServingSource serving = 8;

  // +optional
  optional PulsarSource pulsar = 9;

  // +optional
  optional SqsSource sqs = 10;
}

message SqsSink {
  // AWSRegion is the AWS Region where the SQS queue is located
  optional string awsRegion = 1;

  // QueueName is the name of the SQS queue
  optional string queueName = 2;

  // QueueOwnerAWSAccountID is the queue owner aws account id
  optional string queueOwnerAWSAccountID = 3;

  // AssumeRole contains the configuration for AWS STS assume role.
  // When specified, the SQS client will assume the specified role for authentication.
  // +optional
  optional AWSAssumeRole assumeRole = 4;
}

// SqsSource represents the configuration of an AWS SQS source
message SqsSource {
  // AWSRegion is the AWS Region where the SQS queue is located
  optional string awsRegion = 1;

  // QueueName is the name of the SQS queue
  optional string queueName = 2;

  // QueueOwnerAWSAccountID is the queue owner aws account id
  optional string queueOwnerAWSAccountID = 3;

  // VisibilityTimeout is the duration (in seconds) that the received messages are hidden from subsequent
  // retrieve requests after being retrieved by a ReceiveMessage request.
  // Valid values: 0-43200 (12 hours)
  // +optional
  optional int32 visibilityTimeout = 4;

  // MaxNumberOfMessages is the maximum number of messages to return in a single poll.
  // Valid values: 1-10
  // Defaults to 1
  // +optional
  optional int32 maxNumberOfMessages = 5;

  // WaitTimeSeconds is the duration (in seconds) for which the call waits for a message to arrive
  // in the queue before returning. If a message is available, the call returns sooner than WaitTimeSeconds.
  // Valid values: 0-20
  // Defaults to 0 (short polling)
  // +optional
  optional int32 waitTimeSeconds = 6;

  // EndpointURL is the custom endpoint URL for the AWS SQS API.
  // This is useful for testing with localstack or when using VPC endpoints.
  // +optional
  optional string endpointUrl = 7;

  // AttributeNames is a list of attributes that need to be returned along with each message.
  // Valid values: All | Policy | VisibilityTimeout | MaximumMessageSize | MessageRetentionPeriod |
  // ApproximateNumberOfMessages | ApproximateNumberOfMessagesNotVisible | CreatedTimestamp |
  // LastModifiedTimestamp | QueueArn | ApproximateNumberOfMessagesDelayed | DelaySeconds |
  // ReceiveMessageWaitTimeSeconds | RedrivePolicy | FifoQueue | ContentBasedDeduplication |
  // KmsMasterKeyId | KmsDataKeyReusePeriodSeconds | DeduplicationScope | FifoThroughputLimit |
  // RedriveAllowPolicy | SqsManagedSseEnabled
  // +optional
  repeated string attributeNames = 8;

  // MessageAttributeNames is a list of message attributes that need to be returned along with each message.
  // +optional
  repeated string messageAttributeNames = 9;

  // AssumeRole contains the configuration for AWS STS assume role.
  // When specified, the SQS client will assume the specified role for authentication.
  // +optional
  optional AWSAssumeRole assumeRole = 10;
}

// Status is a common structure which can be used for Status field.
message Status {
  // Conditions are the latest available observations of a resource's current state.
  // +optional
  // +patchMergeKey=type
  // +patchStrategy=merge
  repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 1;
}

message TLS {
  // +optional
  optional bool insecureSkipVerify = 1;

  // CACertSecret refers to the secret that contains the CA cert
  // +optional
  optional .k8s.io.api.core.v1.SecretKeySelector caCertSecret = 2;

  // CertSecret refers to the secret that contains the cert
  // +optional
  optional .k8s.io.api.core.v1.SecretKeySelector certSecret = 3;

  // KeySecret refers to the secret that contains the key
  // +optional
  optional .k8s.io.api.core.v1.SecretKeySelector keySecret = 4;
}

message TagConditions {
  // Operator specifies the type of operation that should be used for conditional forwarding
  // value could be "and", "or", "not"
  // +kubebuilder:validation:Enum=and;or;not
  // +optional
  optional string operator = 1;

  // Values tag values for conditional forwarding
  repeated string values = 2;
}

message Templates {
  // DaemonTemplate is used to customize the Daemon Deployment.
  // +optional
  optional DaemonTemplate daemon = 1;

  // JobTemplate is used to customize Jobs.
  // +optional
  optional JobTemplate job = 2;

  // SideInputsManagerTemplate is used to customize the Side Inputs Manager.
  // +optional
  optional SideInputsManagerTemplate sideInputsManager = 3;

  // VertexTemplate is used to customize the vertices of the pipeline.
  // +optional
  optional VertexTemplate vertex = 4;
}

message UDF {
  // +optional
  optional Container container = 1;

  // +optional
  optional GroupBy groupBy = 3;
}

message UDSink {
  optional Container container = 1;
}

message UDSource {
  optional Container container = 1;
}

message UDTransformer {
  // +optional
  optional Container container = 1;
}

// UpdateStrategy indicates the strategy that the
// controller will use to perform updates for Vertex or MonoVertex.
message UpdateStrategy {
  // Type indicates the type of the StatefulSetUpdateStrategy.
  // Default is RollingUpdate.
  // +optional
  optional string type = 1;

  // RollingUpdate is used to communicate parameters when Type is RollingUpdateStrategy.
  // +optional
  optional RollingUpdateStrategy rollingUpdate = 2;
}

// +genclient
// +kubebuilder:object:root=true
// +kubebuilder:resource:shortName=vtx
// +kubebuilder:subresource:status
// +kubebuilder:subresource:scale:specpath=.spec.replicas,statuspath=.status.replicas,selectorpath=.status.selector
// +kubebuilder:printcolumn:name="Phase",type=string,JSONPath=`.status.phase`
// +kubebuilder:printcolumn:name="Desired",type=string,JSONPath=`.status.desiredReplicas`
// +kubebuilder:printcolumn:name="Current",type=string,JSONPath=`.status.replicas`
// +kubebuilder:printcolumn:name="Ready",type=string,JSONPath=`.status.readyReplicas`
// +kubebuilder:printcolumn:name="Age",type=date,JSONPath=`.metadata.creationTimestamp`
// +kubebuilder:printcolumn:name="Reason",type=string,JSONPath=`.status.reason`
// +kubebuilder:printcolumn:name="Message",type=string,JSONPath=`.status.message`
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +k8s:openapi-gen=true
message Vertex {
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional VertexSpec spec = 2;

  // +optional
  optional VertexStatus status = 3;
}

// VertexInstance is a wrapper of a vertex instance, which contains the vertex spec and the instance information such as hostname and replica index.
message VertexInstance {
  optional Vertex vertex = 1;

  optional string hostname = 2;

  optional int32 replica = 3;
}

message VertexLifecycle {
  // DesiredPhase used to bring the vertex from current phase to desired phase
  // +kubebuilder:default=Running
  // +optional
  optional string desiredPhase = 1;
}

message VertexLimits {
  // Read batch size from the source or buffer.
  // It overrides the settings from pipeline limits.
  // +optional
  optional uint64 readBatchSize = 1;

  // Read timeout duration from the source or buffer
  // It overrides the settings from pipeline limits.
  // +optional
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Duration readTimeout = 2;

  // BufferMaxLength is used to define the max length of a buffer.
  // It overrides the settings from pipeline limits.
  // +optional
  optional uint64 bufferMaxLength = 3;

  // BufferUsageLimit is used to define the percentage of the buffer usage limit, a valid value should be less than 100, for example, 85.
  // It overrides the settings from pipeline limits.
  // +optional
  optional uint32 bufferUsageLimit = 4;

  // RateLimit is used to define the rate limit for the vertex, it overrides the settings from pipeline limits.
  // For Source vertices, the rate limit is defined by how many times the `Read` is called per second multiplied by
  // the `readBatchSize`. Pipeline level rate limit is not applied to Source vertices.
  // +optional
  optional RateLimit rateLimit = 5;
}

// +kubebuilder:object:root=true
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message VertexList {
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated Vertex items = 2;
}

message VertexSpec {
  optional AbstractVertex abstractVertex = 1;

  optional string pipelineName = 2;

  // +optional
  optional string interStepBufferServiceName = 3;

  // +kubebuilder:default=1
  // +optional
  optional int32 replicas = 4;

  // +optional
  repeated CombinedEdge fromEdges = 5;

  // +optional
  repeated CombinedEdge toEdges = 6;

  // Watermark indicates watermark progression in the vertex, it's populated from the pipeline watermark settings.
  // +kubebuilder:default={"disabled": false}
  // +optional
  optional Watermark watermark = 7;

  // Lifecycle defines the Lifecycle properties of a vertex
  // +kubebuilder:default={"desiredPhase": Running}
  // +optional
  optional VertexLifecycle lifecycle = 8;

  // InterStepBuffer configuration specific to this pipeline.
  // +optional
  optional InterStepBuffer interStepBuffer = 9;
}

message VertexStatus {
  optional Status status = 1;

  // +optional
  optional string phase = 2;

  // Total number of non-terminated pods targeted by this Vertex (their labels match the selector).
  // +optional
  optional uint32 replicas = 3;

  // The number of desired replicas.
  // +optional
  optional uint32 desiredReplicas = 4;

  // +optional
  optional string selector = 5;

  // +optional
  optional string reason = 6;

  // +optional
  optional string message = 7;

  // Time of last scaling operation.
  // +optional
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastScaledAt = 8;

  // The generation observed by the Vertex controller.
  // +optional
  optional int64 observedGeneration = 9;

  // The number of pods targeted by this Vertex with a Ready Condition.
  // +optional
  optional uint32 readyReplicas = 10;

  // The number of Pods created by the controller from the Vertex version indicated by updateHash.
  optional uint32 updatedReplicas = 11;

  // The number of ready Pods created by the controller from the Vertex version indicated by updateHash.
  optional uint32 updatedReadyReplicas = 12;

  // If not empty, indicates the current version of the Vertex used to generate Pods.
  optional string currentHash = 13;

  // If not empty, indicates the updated version of the Vertex used to generate Pods.
  optional string updateHash = 14;
}

message VertexTemplate {
  // +optional
  optional AbstractPodTemplate abstractPodTemplate = 1;

  // Template for the vertex numa container
  // +optional
  optional ContainerTemplate containerTemplate = 2;

  // Template for the vertex init container
  // +optional
  optional ContainerTemplate initContainerTemplate = 3;
}

message Watermark {
  // Disabled toggles the watermark propagation, defaults to false.
  // +kubebuilder:default=false
  // +optional
  optional bool disabled = 1;

  // Maximum delay allowed for watermark calculation, defaults to "0s", which means no delay.
  // +kubebuilder:default="0s"
  // +optional
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Duration maxDelay = 2;

  // IdleSource defines the idle watermark properties, it could be configured in case source is idling.
  // +optional
  optional IdleSource idleSource = 3;
}

// Window describes windowing strategy
message Window {
  // +optional
  optional FixedWindow fixed = 1;

  // +optional
  optional SlidingWindow sliding = 2;

  // +optional
  optional SessionWindow session = 3;

  // +optional
  optional AccumulatorWindow accumulator = 4;
}

