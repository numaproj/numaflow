/*


Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/


// This file was autogenerated by go-to-protobuf. Do not edit it manually!

syntax = "proto2";

package github.com.numaproj.numaflow.pkg.apis.numaflow.v1alpha1;

import "k8s.io/api/core/v1/generated.proto";
import "k8s.io/apimachinery/pkg/api/resource/generated.proto";
import "k8s.io/apimachinery/pkg/apis/meta/v1/generated.proto";
import "k8s.io/apimachinery/pkg/runtime/generated.proto";
import "k8s.io/apimachinery/pkg/runtime/schema/generated.proto";

// Package-wide variables from generator "generated".
option go_package = "v1alpha1";

message AbstractVertex {
  optional string name = 1;

  // +optional
  optional Source source = 3;

  // +optional
  optional Sink sink = 4;

  // +optional
  optional ContainerTemplate containerTemplate = 5;

  // +optional
  optional UDF udf = 6;

  // Metadata sets the pods's metadata, i.e. annotations and labels
  optional Metadata metadata = 7;

  // NodeSelector is a selector which must be true for the pod to fit on a node.
  // Selector which must match a node's labels for the pod to be scheduled on that node.
  // More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
  // +optional
  map<string, string> nodeSelector = 8;

  // If specified, the pod's tolerations.
  // +optional
  repeated k8s.io.api.core.v1.Toleration tolerations = 9;

  // SecurityContext holds pod-level security attributes and common container settings.
  // Optional: Defaults to empty.  See type description for default values of each field.
  // +optional
  optional k8s.io.api.core.v1.PodSecurityContext securityContext = 10;

  // ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec.
  // If specified, these secrets will be passed to individual puller implementations for them to use. For example,
  // in the case of docker, only DockerConfig type secrets are honored.
  // More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod
  // +optional
  // +patchMergeKey=name
  // +patchStrategy=merge
  repeated k8s.io.api.core.v1.LocalObjectReference imagePullSecrets = 11;

  // If specified, indicates the Redis pod's priority. "system-node-critical"
  // and "system-cluster-critical" are two special keywords which indicate the
  // highest priorities with the former being the highest priority. Any other
  // name must be defined by creating a PriorityClass object with that name.
  // If not specified, the pod priority will be default or zero if there is no
  // default.
  // More info: https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/
  // +optional
  optional string priorityClassName = 12;

  // The priority value. Various system components use this field to find the
  // priority of the Redis pod. When Priority Admission Controller is enabled,
  // it prevents users from setting this field. The admission controller populates
  // this field from PriorityClassName.
  // The higher the value, the higher the priority.
  // More info: https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/
  // +optional
  optional int32 priority = 13;

  // The pod's scheduling constraints
  // More info: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/
  // +optional
  optional k8s.io.api.core.v1.Affinity affinity = 14;

  // ServiceAccountName to apply to the StatefulSet
  // +optional
  optional string serviceAccountName = 15;

  // +patchStrategy=merge
  // +patchMergeKey=name
  repeated k8s.io.api.core.v1.Volume volumes = 16;

  // Limits define the limitations such as buffer read batch size for all the vertices of a pipleine, will override pipeline level settings
  // +optional
  optional VertexLimits limits = 17;

  // +optional
  optional Scale scale = 18;
}

message Authorization {
  // A secret selector which contains bearer token
  // To use this, the client needs to add "Authorization: Bearer <token>" in the header
  // +optional
  optional k8s.io.api.core.v1.SecretKeySelector token = 1;
}

message BufferServiceConfig {
  optional RedisConfig redis = 1;

  optional JetStreamConfig jetstream = 2;
}

message Container {
  // +optional
  optional string image = 1;

  // +optional
  repeated string command = 2;

  // +optional
  repeated string args = 3;

  // +optional
  repeated k8s.io.api.core.v1.EnvVar env = 4;

  // +optional
  repeated k8s.io.api.core.v1.VolumeMount volumeMounts = 5;

  // +optional
  optional k8s.io.api.core.v1.ResourceRequirements resources = 6;
}

// ContainerTemplate defines customized spec for a container
message ContainerTemplate {
  optional k8s.io.api.core.v1.ResourceRequirements resources = 1;

  optional string imagePullPolicy = 2;

  optional k8s.io.api.core.v1.SecurityContext securityContext = 3;

  repeated k8s.io.api.core.v1.EnvVar env = 4;
}

message Edge {
  optional string from = 1;

  optional string to = 2;

  // Conditional forwarding, only allowed when "From" is a Sink or UDF
  // +optional
  optional ForwardConditions conditions = 3;
}

message ForwardConditions {
  repeated string keyIn = 1;
}

message Function {
  // +kubebuilder:validation:Enum=cat;filter
  optional string name = 1;

  // +optional
  repeated string args = 2;

  // +optional
  map<string, string> kwargs = 3;
}

message GeneratorSource {
  // +kubebuilder:default=5
  // +optional
  optional int64 rpu = 1;

  // +kubebuilder:default="1s"
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Duration duration = 2;

  // Size of each generated message
  // +kubebuilder:default=8
  // +optional
  optional int32 msgSize = 3;
}

message GetDaemonDeploymentReq {
  optional string isbSvcType = 1;

  optional string image = 2;

  optional string pullPolicy = 3;

  repeated k8s.io.api.core.v1.EnvVar env = 4;
}

message GetJetStreamServiceSpecReq {
  map<string, string> labels = 1;

  optional int32 clusterPort = 2;

  optional int32 clientPort = 3;

  optional int32 monitorPort = 4;

  optional int32 metricsPort = 5;
}

message GetJetStreamStatefulSetSpecReq {
  optional string serviceName = 1;

  map<string, string> labels = 2;

  optional string natsImage = 3;

  optional string metricsExporterImage = 4;

  optional string configReloaderImage = 5;

  optional int32 clusterPort = 6;

  optional int32 clientPort = 7;

  optional int32 monitorPort = 8;

  optional int32 metricsPort = 9;

  optional string serverAuthSecretName = 10;

  optional string serverEncryptionSecretName = 11;

  optional string configMapName = 12;

  optional string pvcNameIfNeeded = 13;

  optional string startCommand = 14;
}

message GetRedisServiceSpecReq {
  map<string, string> labels = 1;

  optional int32 redisContainerPort = 2;

  optional int32 sentinelContainerPort = 3;
}

message GetRedisStatefulSetSpecReq {
  optional string serviceName = 1;

  map<string, string> labels = 2;

  optional string redisImage = 3;

  optional string sentinelImage = 4;

  optional string metricsExporterImage = 5;

  optional string initContainerImage = 6;

  optional int32 redisContainerPort = 7;

  optional int32 sentinelContainerPort = 8;

  optional int32 redisMetricsContainerPort = 9;

  optional string credentialSecretName = 10;

  optional bool tlsEnabled = 11;

  optional string pvcNameIfNeeded = 12;

  optional string confConfigMapName = 13;

  optional string scriptsConfigMapName = 14;

  optional string healthConfigMapName = 15;
}

message GetVertexPodSpecReq {
  optional string isbSvcType = 1;

  optional string image = 2;

  optional string pullPolicy = 3;

  repeated k8s.io.api.core.v1.EnvVar env = 4;
}

message HTTPSource {
  // +optional
  optional Authorization auth = 1;

  // Whether to create a ClusterIP Service
  // +optional
  optional bool service = 2;
}

// +genclient
// +kubebuilder:object:root=true
// +kubebuilder:resource:shortName=isbsvc
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Phase",type=string,JSONPath=`.status.phase`
// +kubebuilder:printcolumn:name="Message",type=string,JSONPath=`.status.message`
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +k8s:openapi-gen=true
message InterStepBufferService {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional InterStepBufferServiceSpec spec = 2;

  // +optional
  optional InterStepBufferServiceStatus status = 3;
}

// InterStepBufferServiceList is the list of InterStepBufferService resources
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message InterStepBufferServiceList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated InterStepBufferService items = 2;
}

message InterStepBufferServiceSpec {
  optional RedisBuferService redis = 1;

  optional JetStreamBufferService jetstream = 2;
}

message InterStepBufferServiceStatus {
  optional Status status = 1;

  optional string phase = 2;

  optional string message = 3;

  optional BufferServiceConfig config = 4;
}

message JetStreamBufferService {
  // JetStream version, such as "2.7.1"
  optional string version = 1;

  // Redis StatefulSet size
  // +kubebuilder:default=3
  optional int32 replicas = 2;

  // ContainerTemplate contains customized spec for NATS container
  // +optional
  optional ContainerTemplate containerTemplate = 3;

  // ReloaderContainerTemplate contains customized spec for config reloader container
  // +optional
  optional ContainerTemplate reloaderContainerTemplate = 4;

  // MetricsContainerTemplate contains customized spec for metrics container
  // +optional
  optional ContainerTemplate metricsContainerTemplate = 5;

  // +optional
  optional PersistenceStrategy persistence = 6;

  // Metadata sets the pods's metadata, i.e. annotations and labels
  optional Metadata metadata = 77;

  // NodeSelector is a selector which must be true for the pod to fit on a node.
  // Selector which must match a node's labels for the pod to be scheduled on that node.
  // More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
  // +optional
  map<string, string> nodeSelector = 8;

  // If specified, the pod's tolerations.
  // +optional
  repeated k8s.io.api.core.v1.Toleration tolerations = 9;

  // SecurityContext holds pod-level security attributes and common container settings.
  // Optional: Defaults to empty.  See type description for default values of each field.
  // +optional
  optional k8s.io.api.core.v1.PodSecurityContext securityContext = 10;

  // ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec.
  // If specified, these secrets will be passed to individual puller implementations for them to use. For example,
  // in the case of docker, only DockerConfig type secrets are honored.
  // More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod
  // +optional
  // +patchMergeKey=name
  // +patchStrategy=merge
  repeated k8s.io.api.core.v1.LocalObjectReference imagePullSecrets = 11;

  // If specified, indicates the Redis pod's priority. "system-node-critical"
  // and "system-cluster-critical" are two special keywords which indicate the
  // highest priorities with the former being the highest priority. Any other
  // name must be defined by creating a PriorityClass object with that name.
  // If not specified, the pod priority will be default or zero if there is no
  // default.
  // More info: https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/
  // +optional
  optional string priorityClassName = 12;

  // The priority value. Various system components use this field to find the
  // priority of the Redis pod. When Priority Admission Controller is enabled,
  // it prevents users from setting this field. The admission controller populates
  // this field from PriorityClassName.
  // The higher the value, the higher the priority.
  // More info: https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/
  // +optional
  optional int32 priority = 13;

  // The pod's scheduling constraints
  // More info: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/
  // +optional
  optional k8s.io.api.core.v1.Affinity affinity = 14;

  // ServiceAccountName to apply to the StatefulSet
  // +optional
  optional string serviceAccountName = 15;

  // JetStream configuration, if not specified, global settings in numaflow-controller-config will be used.
  // See https://docs.nats.io/running-a-nats-service/configuration#jetstream.
  // Only configure "max_memory_store" or "max_file_store", do not set "store_dir" as it has been hardcoded.
  // +optional
  optional string settings = 16;

  // Optional arguments to start nats-server. For example, "-D" to enable debugging output, "-DV" to enable debugging and tracing.
  // Check https://docs.nats.io/ for all the available arguments.
  // +optional
  repeated string startArgs = 17;

  // Optional configuration for the streams, consumers and buckets to be created in this JetStream service, if specified, it will be merged with the default configuration in numaflow-controller-config.
  // It accepts a YAML format configuration, it may include 4 sections, "stream", "consumer", "otBucket" and "procBucket".
  // Available fields under "stream" include "retention" (e.g. interest, limits, workerQueue), "maxMsgs", "maxAge" (e.g. 72h), "replicas" (1, 3, 5), "duplicates" (e.g. 5m).
  // Available fields under "consumer" include "ackWait" (e.g. 60s)
  // Available fields under "otBucket" include "maxValueSize", "history", "ttl" (e.g. 72h), "maxBytes", "replicas" (1, 3, 5).
  // Available fields under "procBucket" include "maxValueSize", "history", "ttl" (e.g. 72h), "maxBytes", "replicas" (1, 3, 5).
  // +optional
  optional string bufferConfig = 18;

  // Whether encrypt the data at rest, defaults to false
  // Enabling encryption might impact the performace, see https://docs.nats.io/running-a-nats-service/nats_admin/jetstream_admin/encryption_at_rest for the detail
  // Toggling the value will impact encypting/decrypting existing messages.
  // +optional
  optional bool encryption = 19;

  // Whether enable TLS, defaults to false
  // Enabling TLS might impact the performace
  // +optional
  optional bool tls = 20;
}

message JetStreamConfig {
  // JetStream (NATS) URL
  optional string url = 1;

  optional NATSAuth auth = 2;

  // +optional
  optional string bufferConfig = 3;

  // TLS enabled or not
  optional bool tlsEnabled = 4;
}

message KafkaSink {
  repeated string brokers = 1;

  optional string topic = 2;

  // TLS user to configure TLS connection for kafka broker
  // TLS.enable=true default for TLS.
  // +optional
  optional TLS tls = 3;

  // +optional
  optional string config = 4;

  // concurrency used to concurrently send message to kafka producer.
  // +kubebuilder:default=100
  // +optional
  optional uint32 concurrency = 5;
}

message KafkaSource {
  repeated string brokers = 1;

  optional string topic = 2;

  optional string consumerGroup = 3;

  // TLS user to configure TLS connection for kafka broker
  // TLS.enable=true default for TLS.
  // +optional
  optional TLS tls = 4;

  // +optional
  optional string config = 5;
}

message Lifecycle {
  // DeleteGracePeriodSeconds used to delete pipeline gracefully
  // +kubebuilder:default=30
  // +optional
  optional int32 deleteGracePeriodSeconds = 1;

  // DesiredPhase used to bring the pipeline from current phase to desired phase
  // +kubebuilder:default=Running
  // +optional
  optional string desiredPhase = 2;
}

message Log {
}

message Metadata {
  map<string, string> annotations = 1;

  map<string, string> labels = 2;
}

message NATSAuth {
  // Secret for auth user
  // +optional
  optional k8s.io.api.core.v1.SecretKeySelector user = 1;

  // Secret for auth password
  // +optional
  optional k8s.io.api.core.v1.SecretKeySelector password = 2;
}

message NativeRedis {
  // Redis version, such as "6.0.16"
  optional string version = 1;

  // Redis StatefulSet size
  // +kubebuilder:default=3
  optional int32 replicas = 2;

  // RedisContainerTemplate contains customized spec for Redis container
  // +optional
  optional ContainerTemplate redisContainerTemplate = 3;

  // SentinelContainerTemplate contains customized spec for Redis container
  // +optional
  optional ContainerTemplate sentinelContainerTemplate = 4;

  // MetricsContainerTemplate contains customized spec for metrics container
  // +optional
  optional ContainerTemplate metricsContainerTemplate = 5;

  // +optional
  optional PersistenceStrategy persistence = 6;

  // Metadata sets the pods's metadata, i.e. annotations and labels
  optional Metadata metadata = 7;

  // NodeSelector is a selector which must be true for the pod to fit on a node.
  // Selector which must match a node's labels for the pod to be scheduled on that node.
  // More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
  // +optional
  map<string, string> nodeSelector = 8;

  // If specified, the pod's tolerations.
  // +optional
  repeated k8s.io.api.core.v1.Toleration tolerations = 9;

  // SecurityContext holds pod-level security attributes and common container settings.
  // Optional: Defaults to empty.  See type description for default values of each field.
  // +optional
  optional k8s.io.api.core.v1.PodSecurityContext securityContext = 10;

  // ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec.
  // If specified, these secrets will be passed to individual puller implementations for them to use. For example,
  // in the case of docker, only DockerConfig type secrets are honored.
  // More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod
  // +optional
  // +patchMergeKey=name
  // +patchStrategy=merge
  repeated k8s.io.api.core.v1.LocalObjectReference imagePullSecrets = 11;

  // If specified, indicates the Redis pod's priority. "system-node-critical"
  // and "system-cluster-critical" are two special keywords which indicate the
  // highest priorities with the former being the highest priority. Any other
  // name must be defined by creating a PriorityClass object with that name.
  // If not specified, the pod priority will be default or zero if there is no
  // default.
  // More info: https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/
  // +optional
  optional string priorityClassName = 12;

  // The priority value. Various system components use this field to find the
  // priority of the Redis pod. When Priority Admission Controller is enabled,
  // it prevents users from setting this field. The admission controller populates
  // this field from PriorityClassName.
  // The higher the value, the higher the priority.
  // More info: https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/
  // +optional
  optional int32 priority = 13;

  // The pod's scheduling constraints
  // More info: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/
  // +optional
  optional k8s.io.api.core.v1.Affinity affinity = 14;

  // ServiceAccountName to apply to the StatefulSet
  // +optional
  optional string serviceAccountName = 15;

  // Redis configuration, if not specified, global settings in numaflow-controller-config will be used.
  // +optional
  optional RedisSettings settings = 16;
}

// PersistenceStrategy defines the strategy of persistence
message PersistenceStrategy {
  // Name of the StorageClass required by the claim.
  // More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
  // +optional
  optional string storageClassName = 1;

  // Available access modes such as ReadWriteOnce, ReadWriteMany
  // https://kubernetes.io/docs/concepts/storage/persistent-volumes/#access-modes
  // +optional
  optional string accessMode = 2;

  // Volume size, e.g. 50Gi
  optional k8s.io.apimachinery.pkg.api.resource.Quantity volumeSize = 3;
}

// +genclient
// +kubebuilder:object:root=true
// +kubebuilder:resource:shortName=pl
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Phase",type=string,JSONPath=`.status.phase`
// +kubebuilder:printcolumn:name="Message",type=string,JSONPath=`.status.message`
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +k8s:openapi-gen=true
message Pipeline {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional PipelineSpec spec = 2;

  // +optional
  optional PipelineStatus status = 3;
}

message PipelineLimits {
  // Read batch size for all the vertices in the pipeline, can be overridden by the vertex's limit settings
  // +kubebuilder:default=100
  // +optional
  optional uint64 readBatchSize = 1;

  // Workers used to concurrently call UDF functions, it's only meaningful for UDF vertex, and will be ignored by source and sink vertices.
  // It can be overridden by the vertex's limit settings
  // +kubebuilder:default=100
  // +optional
  optional uint32 udfWorkers = 2;

  // BufferMaxLength is used to define the max length of a buffer
  // Only applies to UDF and Source vertice as only they do buffer write.
  // It can be overridden by the settings in vertex limits.
  // +kubebuilder:default=10000
  // +optional
  optional uint64 bufferMaxLength = 3;

  // BufferUsageLimit is used to define the pencentage of the buffer usage limit, a valid value should be less than 100, for example, 85.
  // Only applies to UDF and Source vertice as only they do buffer write.
  // It will be overridden by the settings in vertex limits.
  // +kubebuilder:default=80
  // +optional
  optional uint32 bufferUsageLimit = 4;
}

// +kubebuilder:object:root=true
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message PipelineList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated Pipeline items = 2;
}

message PipelineSpec {
  // +optional
  optional string interStepBufferServiceName = 1;

  // +patchStrategy=merge
  // +patchMergeKey=name
  repeated AbstractVertex vertices = 2;

  // Edges define the relationships between vertices
  repeated Edge edges = 3;

  // Lifecycle define the Lifecycle properties
  // +patchStrategy=merge
  // +patchMergeKey=name
  // +kubebuilder:default={"deleteGracePeriodSeconds": 30, "desiredPhase": Running}
  // +optional
  optional Lifecycle lifecycle = 4;

  // Limits define the limitations such as buffer read batch size for all the vertices of a pipleine, they could be overridden by each vertex's settings
  // +kubebuilder:default={"readBatchSize": 100, "udfWorkers": 100, "bufferMaxLength": 10000, "bufferUsageLimit": 80}
  // +optional
  optional PipelineLimits limits = 5;

  // Watermark enables watermark progression across the entire pipeline. Updating this after the pipeline has been
  // created will have no impact and will be ignored. To make the pipeline honor any changes to the setting, the pipeline
  // should be recreated.
  // +kubebuilder:default={"propagate": false}
  // +optional
  optional Watermark watermark = 6;
}

message PipelineStatus {
  optional Status status = 1;

  optional string phase = 2;

  optional string message = 3;

  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastUpdated = 4;
}

message RedisBuferService {
  // Native brings up a native Redis service
  optional NativeRedis native = 1;

  // External holds an External Redis config
  optional RedisConfig external = 2;
}

message RedisConfig {
  // Redis URL
  // +optional
  optional string url = 1;

  // Sentinel URL, will be ignored if Redis URL is provided
  // +optional
  optional string sentinelUrl = 2;

  // Only required when Sentinel is used
  // +optional
  optional string masterName = 3;

  // Redis user
  // +optional
  optional string user = 4;

  // Redis password secret selector
  // +optional
  optional k8s.io.api.core.v1.SecretKeySelector password = 5;

  // Sentinel password secret selector
  // +optional
  optional k8s.io.api.core.v1.SecretKeySelector sentinelPassword = 6;
}

message RedisSettings {
  // Redis settings shared by both master and slaves, will override the global settings from controller config
  // +optional
  optional string redis = 1;

  // Special settings for Redis master node, will override the global settings from controller config
  // +optional
  optional string master = 2;

  // Special settings for Redis replica nodes, will override the global settings from controller config
  // +optional
  optional string replica = 3;

  // Sentinel settings, will override the global settings from controller config
  // +optional
  optional string sentinel = 4;
}

message Scale {
  // Minimal replicas
  // +kubebuilder:default=1
  // +optional
  optional int32 min = 1;

  // Maximum replicas
  // +kubebuilder:default=1
  // +optional
  optional int32 max = 2;
}

message Sink {
  optional Log log = 1;

  optional KafkaSink kafka = 2;

  optional UDSink udsink = 3;
}

message Source {
  // +optional
  optional GeneratorSource generator = 1;

  // +optional
  optional KafkaSource kafka = 2;

  // +optional
  optional HTTPSource http = 3;
}

// Status is a common structure which can be used for Status field.
message Status {
  // Conditions are the latest available observations of a resource's current state.
  // +optional
  // +patchMergeKey=type
  // +patchStrategy=merge
  repeated k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 1;
}

message TLS {
  // +optional
  optional bool insecureSkipVerify = 1;

  // CACertSecret refers to the secret that contains the CA cert
  // +optional
  optional k8s.io.api.core.v1.SecretKeySelector caCertSecret = 2;

  // CertSecret refers to the secret that contains the cert
  // +optional
  optional k8s.io.api.core.v1.SecretKeySelector certSecret = 3;

  // KeySecret refers to the secret that contains the key
  // +optional
  optional k8s.io.api.core.v1.SecretKeySelector keySecret = 4;
}

message ToVertex {
  optional string name = 1;

  // +optional
  optional ForwardConditions conditions = 2;
}

message UDF {
  // +optional
  optional Container container = 1;

  // +optional
  optional Function builtin = 12;
}

message UDSink {
  optional Container container = 1;
}

// +genclient
// +kubebuilder:object:root=true
// +kubebuilder:resource:shortName=vtx
// +kubebuilder:subresource:status
// +kubebuilder:subresource:scale:specpath=.spec.replicas,statuspath=.status.replicas,selectorpath=.status.selector
// +kubebuilder:printcolumn:name="Phase",type=string,JSONPath=`.status.phase`
// +kubebuilder:printcolumn:name="Reason",type=string,JSONPath=`.status.reason`
// +kubebuilder:printcolumn:name="Message",type=string,JSONPath=`.status.message`
// +kubebuilder:printcolumn:name="Desired",type=string,JSONPath=`.spec.replicas`
// +kubebuilder:printcolumn:name="Current",type=string,JSONPath=`.status.replicas`
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +k8s:openapi-gen=true
message Vertex {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional VertexSpec spec = 2;

  // +optional
  optional VertexStatus status = 3;
}

message VertexLimits {
  // Read batch size
  // +optional
  optional uint64 readBatchSize = 1;

  // Workers used to concurrently call UDF functions, it's only meaningful for UDF vertex, and will be ignored by source and sink vertices.
  // It overrides the setting in pipeline limits.
  // +optional
  optional uint32 udfWorkers = 2;

  // BufferMaxLength is used to define the max length of a buffer.
  // It overrides the settings from pipeline limits.
  // Only meaningful for UDF and Source vertice as only they do buffer write.
  // +optional
  optional uint64 bufferMaxLength = 3;

  // BufferUsageLimit is used to define the pencentage of the buffer usage limit, a valid value should be less than 100, for example, 85.
  // It overrides the settings from pipeline limits.
  // Only meaningful for UDF and Source vertice as only they do buffer write.
  // +optional
  optional uint32 bufferUsageLimit = 4;
}

// +kubebuilder:object:root=true
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message VertexList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated Vertex items = 2;
}

message VertexSpec {
  optional AbstractVertex abstractVertex = 1;

  optional string pipelineName = 2;

  // +optional
  optional string interStepBufferServiceName = 3;

  // +kubebuilder:default=1
  // +optional
  optional int32 replicas = 4;

  // +optional
  repeated string fromVertices = 5;

  // +optional
  repeated ToVertex toVertices = 6;
}

message VertexStatus {
  optional string phase = 1;

  optional string reason = 6;

  optional string message = 2;

  optional uint32 replicas = 3;

  optional string selector = 5;

  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastScaledAt = 4;
}

message Watermark {
  // Propagate toggles the watermark propagation.
  // +kubebuilder:default=false
  // +optional
  optional bool propagate = 1;
}

