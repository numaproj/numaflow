/*
Copyright 2022 The Numaproj Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/


// This file was autogenerated by go-to-protobuf. Do not edit it manually!

syntax = "proto2";

package github.com.numaproj.numaflow.pkg.apis.numaflow.v1alpha1;

import "k8s.io/api/core/v1/generated.proto";
import "k8s.io/apimachinery/pkg/api/resource/generated.proto";
import "k8s.io/apimachinery/pkg/apis/meta/v1/generated.proto";
import "k8s.io/apimachinery/pkg/runtime/generated.proto";
import "k8s.io/apimachinery/pkg/runtime/schema/generated.proto";
import "k8s.io/apimachinery/pkg/util/intstr/generated.proto";

// Package-wide variables from generator "generated".
option go_package = "github.com/numaproj/numaflow/pkg/apis/numaflow/v1alpha1";

// AbstractPodTemplate provides a template for pod customization in vertices, daemon deployments and so on.
message AbstractPodTemplate {
  // Metadata sets the pods's metadata, i.e. annotations and labels
  // +optional
  optional Metadata metadata = 1;

  // NodeSelector is a selector which must be true for the pod to fit on a node.
  // Selector which must match a node's labels for the pod to be scheduled on that node.
  // More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
  // +optional
  map<string, string> nodeSelector = 2;

  // If specified, the pod's tolerations.
  // +optional
  repeated .k8s.io.api.core.v1.Toleration tolerations = 3;

  // SecurityContext holds pod-level security attributes and common container settings.
  // Optional: Defaults to empty.  See type description for default values of each field.
  // +optional
  optional .k8s.io.api.core.v1.PodSecurityContext securityContext = 4;

  // ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec.
  // If specified, these secrets will be passed to individual puller implementations for them to use. For example,
  // in the case of docker, only DockerConfig type secrets are honored.
  // More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod
  // +optional
  // +patchMergeKey=name
  // +patchStrategy=merge
  repeated .k8s.io.api.core.v1.LocalObjectReference imagePullSecrets = 5;

  // If specified, indicates the Redis pod's priority. "system-node-critical"
  // and "system-cluster-critical" are two special keywords which indicate the
  // highest priorities with the former being the highest priority. Any other
  // name must be defined by creating a PriorityClass object with that name.
  // If not specified, the pod priority will be default or zero if there is no
  // default.
  // More info: https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/
  // +optional
  optional string priorityClassName = 6;

  // The priority value. Various system components use this field to find the
  // priority of the Redis pod. When Priority Admission Controller is enabled,
  // it prevents users from setting this field. The admission controller populates
  // this field from PriorityClassName.
  // The higher the value, the higher the priority.
  // More info: https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/
  // +optional
  optional int32 priority = 7;

  // The pod's scheduling constraints
  // More info: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/
  // +optional
  optional .k8s.io.api.core.v1.Affinity affinity = 8;

  // ServiceAccountName applied to the pod
  // +optional
  optional string serviceAccountName = 9;

  // RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used
  // to run this pod.  If no RuntimeClass resource matches the named class, the pod will not be run.
  // If unset or empty, the "legacy" RuntimeClass will be used, which is an implicit class with an
  // empty definition that uses the default runtime handler.
  // More info: https://git.k8s.io/enhancements/keps/sig-node/585-runtime-class
  // +optional
  optional string runtimeClassName = 10;

  // AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.
  // +optional
  optional bool automountServiceAccountToken = 11;

  // Set DNS policy for the pod.
  // Defaults to "ClusterFirst".
  // Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'.
  // DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy.
  // To have DNS options set along with hostNetwork, you have to specify DNS policy
  // explicitly to 'ClusterFirstWithHostNet'.
  // +optional
  optional string dnsPolicy = 12;

  // Specifies the DNS parameters of a pod.
  // Parameters specified here will be merged to the generated DNS
  // configuration based on DNSPolicy.
  // +optional
  optional .k8s.io.api.core.v1.PodDNSConfig dnsConfig = 13;

  // ResourceClaims defines which ResourceClaims must be allocated and reserved
  // before the Pod is allowed to start. The resources will be made available to those
  // containers which consume them by name.
  // +patchMergeKey=name
  // +patchStrategy=merge,retainKeys
  // +optional
  repeated .k8s.io.api.core.v1.PodResourceClaim resourceClaims = 14;
}

message AbstractSink {
  // Log sink is used to write the data to the log.
  // +optional
  optional Log log = 1;

  // Kafka sink is used to write the data to the Kafka.
  // +optional
  optional KafkaSink kafka = 2;

  // Blackhole sink is used to write the data to the blackhole sink,
  // which is a sink that discards all the data written to it.
  // +optional
  optional Blackhole blackhole = 3;

  // UDSink sink is used to write the data to the user-defined sink.
  // +optional
  optional UDSink udsink = 4;
}

message AbstractVertex {
  optional string name = 1;

  // +optional
  optional Source source = 2;

  // +optional
  optional Sink sink = 3;

  // +optional
  optional UDF udf = 4;

  // Container template for the main numa container.
  // +optional
  optional ContainerTemplate containerTemplate = 5;

  // Container template for all the vertex pod init containers spawned by numaflow, excluding the ones specified by the user.
  // +optional
  optional ContainerTemplate initContainerTemplate = 6;

  // +optional
  optional AbstractPodTemplate abstractPodTemplate = 7;

  // +optional
  // +patchStrategy=merge
  // +patchMergeKey=name
  repeated .k8s.io.api.core.v1.Volume volumes = 8;

  // Limits define the limitations such as buffer read batch size for all the vertices of a pipeline, will override pipeline level settings
  // +optional
  optional VertexLimits limits = 9;

  // Settings for autoscaling
  // +optional
  optional Scale scale = 10;

  // List of customized init containers belonging to the pod.
  // More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
  // +optional
  repeated .k8s.io.api.core.v1.Container initContainers = 11;

  // List of customized sidecar containers belonging to the pod.
  // +optional
  repeated .k8s.io.api.core.v1.Container sidecars = 12;

  // Number of partitions of the vertex owned buffers.
  // It applies to udf and sink vertices only.
  // +optional
  optional int32 partitions = 13;

  // Names of the side inputs used in this vertex.
  // +optional
  repeated string sideInputs = 14;

  // Container template for the side inputs watcher container.
  // +optional
  optional ContainerTemplate sideInputsContainerTemplate = 15;

  // The strategy to use to replace existing pods with new ones.
  // +kubebuilder:default={"type": "RollingUpdate", "rollingUpdate": {"maxUnavailable": "25%"}}
  // +optional
  optional UpdateStrategy updateStrategy = 16;
}

message Authorization {
  // A secret selector which contains bearer token
  // To use this, the client needs to add "Authorization: Bearer <token>" in the header
  // +optional
  optional .k8s.io.api.core.v1.SecretKeySelector token = 1;
}

// Backoff defines parameters used to systematically configure the retry strategy.
message Backoff {
  // Interval sets the delay to wait before retry, after a failure occurs.
  // +kubebuilder:default="1ms"
  // +optional
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Duration interval = 1;

  // Steps defines the number of times to try writing to a sink including retries
  // +optional
  optional uint32 steps = 2;
}

// BasicAuth represents the basic authentication approach which contains a user name and a password.
message BasicAuth {
  // Secret for auth user
  // +optional
  optional .k8s.io.api.core.v1.SecretKeySelector user = 1;

  // Secret for auth password
  // +optional
  optional .k8s.io.api.core.v1.SecretKeySelector password = 2;
}

// Blackhole is a sink to emulate /dev/null
message Blackhole {
}

message BufferServiceConfig {
  optional RedisConfig redis = 1;

  optional JetStreamConfig jetstream = 2;
}

// CombinedEdge is a combination of Edge and some other properties such as vertex type, partitions, limits.
// It's used to decorate the fromEdges and toEdges of the generated Vertex objects, so that in the vertex pod,
// it knows the properties of the connected vertices, for example, how many partitioned buffers I should write
// to, what is the write buffer length, etc.
message CombinedEdge {
  optional Edge edge = 1;

  // From vertex type.
  optional string fromVertexType = 2;

  // The number of partitions of the from vertex, if not provided, the default value is set to "1".
  // +optional
  optional int32 fromVertexPartitionCount = 3;

  // +optional
  optional VertexLimits fromVertexLimits = 4;

  // To vertex type.
  optional string toVertexType = 5;

  // The number of partitions of the to vertex, if not provided, the default value is set to "1".
  // +optional
  optional int32 toVertexPartitionCount = 6;

  // +optional
  optional VertexLimits toVertexLimits = 7;
}

// Container is used to define the container properties for user-defined functions, sinks, etc.
message Container {
  // +optional
  optional string image = 1;

  // +optional
  repeated string command = 2;

  // +optional
  repeated string args = 3;

  // +optional
  repeated .k8s.io.api.core.v1.EnvVar env = 4;

  // +optional
  repeated .k8s.io.api.core.v1.EnvFromSource envFrom = 5;

  // +optional
  repeated .k8s.io.api.core.v1.VolumeMount volumeMounts = 6;

  // +optional
  optional .k8s.io.api.core.v1.ResourceRequirements resources = 7;

  // +optional
  optional .k8s.io.api.core.v1.SecurityContext securityContext = 8;

  // +optional
  optional string imagePullPolicy = 9;

  // +optional
  optional Probe readinessProbe = 10;

  // +optional
  optional Probe livenessProbe = 11;

  // +optional
  // +patchMergeKey=containerPort
  // +patchStrategy=merge
  // +listType=map
  // +listMapKey=containerPort
  // +listMapKey=protocol
  repeated .k8s.io.api.core.v1.ContainerPort ports = 12;
}

// ContainerTemplate defines customized spec for a container
message ContainerTemplate {
  // +optional
  optional .k8s.io.api.core.v1.ResourceRequirements resources = 1;

  // +optional
  optional string imagePullPolicy = 2;

  // +optional
  optional .k8s.io.api.core.v1.SecurityContext securityContext = 3;

  // +optional
  repeated .k8s.io.api.core.v1.EnvVar env = 4;

  // +optional
  repeated .k8s.io.api.core.v1.EnvFromSource envFrom = 5;

  // +optional
  optional Probe readinessProbe = 6;

  // +optional
  optional Probe livenessProbe = 7;
}

message DaemonTemplate {
  // +optional
  optional AbstractPodTemplate abstractPodTemplate = 1;

  // Replicas is the number of desired replicas of the Deployment.
  // This is a pointer to distinguish between explicit zero and unspecified.
  // Defaults to 1.
  // More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#what-is-a-replicationcontroller
  // +optional
  optional int32 replicas = 2;

  // +optional
  optional ContainerTemplate containerTemplate = 3;

  // +optional
  optional ContainerTemplate initContainerTemplate = 4;
}

message Edge {
  optional string from = 1;

  optional string to = 2;

  // Conditional forwarding, only allowed when "From" is a Source or UDF.
  // +optional
  optional ForwardConditions conditions = 3;

  // OnFull specifies the behaviour for the write actions when the inter step buffer is full.
  // There are currently two options, retryUntilSuccess and discardLatest.
  // if not provided, the default value is set to "retryUntilSuccess"
  // +kubebuilder:validation:Enum=retryUntilSuccess;discardLatest
  // +optional
  optional string onFull = 4;
}

// FixedWindow describes a fixed window
message FixedWindow {
  // Length is the duration of the fixed window.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Duration length = 1;

  // +optional
  // Streaming should be set to true if the reduce udf is streaming.
  optional bool streaming = 2;
}

message ForwardConditions {
  // Tags used to specify tags for conditional forwarding
  optional TagConditions tags = 1;
}

message Function {
  // +kubebuilder:validation:Enum=cat;filter
  optional string name = 1;

  // +optional
  repeated string args = 2;

  // +optional
  map<string, string> kwargs = 3;
}

// GSSAPI represents a SASL GSSAPI config
message GSSAPI {
  optional string serviceName = 1;

  optional string realm = 2;

  // UsernameSecret refers to the secret that contains the username
  optional .k8s.io.api.core.v1.SecretKeySelector usernameSecret = 3;

  // valid inputs - KRB5_USER_AUTH, KRB5_KEYTAB_AUTH
  optional string authType = 4;

  // PasswordSecret refers to the secret that contains the password
  // +optional
  optional .k8s.io.api.core.v1.SecretKeySelector passwordSecret = 5;

  // KeytabSecret refers to the secret that contains the keytab
  // +optional
  optional .k8s.io.api.core.v1.SecretKeySelector keytabSecret = 6;

  // KerberosConfigSecret refers to the secret that contains the kerberos config
  // +optional
  optional .k8s.io.api.core.v1.SecretKeySelector kerberosConfigSecret = 7;
}

message GeneratorSource {
  // +kubebuilder:default=5
  // +optional
  optional int64 rpu = 1;

  // +kubebuilder:default="1s"
  // +optional
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Duration duration = 2;

  // Size of each generated message
  // +kubebuilder:default=8
  // +optional
  optional int32 msgSize = 3;

  // KeyCount is the number of unique keys in the payload
  // +optional
  optional int32 keyCount = 4;

  // Value is an optional uint64 value to be written in to the payload
  // +optional
  optional uint64 value = 5;

  // Jitter is the jitter for the message generation, used to simulate out of order messages
  // for example if the jitter is 10s, then the message's event time will be delayed by a random
  // time between 0 and 10s which will result in the message being out of order by 0 to 10s
  // +kubebuilder:default="0s"
  // +optional
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Duration jitter = 6;

  // ValueBlob is an optional string which is the base64 encoding of direct payload to send.
  // This is useful for attaching a GeneratorSource to a true pipeline to test load behavior
  // with true messages without requiring additional work to generate messages through
  // the external source
  // if present, the Value and MsgSize fields will be ignored.
  // +optional
  optional string valueBlob = 7;
}

message GetDaemonDeploymentReq {
  optional string isbSvcType = 1;

  optional string image = 2;

  optional string pullPolicy = 3;

  repeated .k8s.io.api.core.v1.EnvVar env = 4;

  optional .k8s.io.api.core.v1.ResourceRequirements defaultResources = 5;
}

message GetJetStreamServiceSpecReq {
  map<string, string> labels = 1;

  optional int32 clusterPort = 2;

  optional int32 clientPort = 3;

  optional int32 monitorPort = 4;

  optional int32 metricsPort = 5;
}

message GetJetStreamStatefulSetSpecReq {
  optional string serviceName = 1;

  map<string, string> labels = 2;

  optional string natsImage = 3;

  optional string metricsExporterImage = 4;

  optional string configReloaderImage = 5;

  optional int32 clusterPort = 6;

  optional int32 clientPort = 7;

  optional int32 monitorPort = 8;

  optional int32 metricsPort = 9;

  optional string serverAuthSecretName = 10;

  optional string serverEncryptionSecretName = 11;

  optional string configMapName = 12;

  optional string pvcNameIfNeeded = 13;

  optional string startCommand = 14;

  optional .k8s.io.api.core.v1.ResourceRequirements defaultResources = 15;
}

message GetMonoVertexDaemonDeploymentReq {
  optional string image = 1;

  optional string pullPolicy = 2;

  repeated .k8s.io.api.core.v1.EnvVar env = 3;

  optional .k8s.io.api.core.v1.ResourceRequirements defaultResources = 4;
}

message GetMonoVertexPodSpecReq {
  optional string image = 1;

  optional string pullPolicy = 2;

  repeated .k8s.io.api.core.v1.EnvVar env = 3;

  optional .k8s.io.api.core.v1.ResourceRequirements defaultResources = 4;
}

message GetRedisServiceSpecReq {
  map<string, string> labels = 1;

  optional int32 redisContainerPort = 2;

  optional int32 sentinelContainerPort = 3;
}

message GetRedisStatefulSetSpecReq {
  optional string serviceName = 1;

  map<string, string> labels = 2;

  optional string redisImage = 3;

  optional string sentinelImage = 4;

  optional string metricsExporterImage = 5;

  optional string initContainerImage = 6;

  optional int32 redisContainerPort = 7;

  optional int32 sentinelContainerPort = 8;

  optional int32 redisMetricsContainerPort = 9;

  optional string credentialSecretName = 10;

  optional bool tlsEnabled = 11;

  optional string pvcNameIfNeeded = 12;

  optional string confConfigMapName = 13;

  optional string scriptsConfigMapName = 14;

  optional string healthConfigMapName = 15;

  optional .k8s.io.api.core.v1.ResourceRequirements defaultResources = 16;
}

message GetSideInputDeploymentReq {
  optional string isbSvcType = 1;

  optional string image = 2;

  optional string pullPolicy = 3;

  repeated .k8s.io.api.core.v1.EnvVar env = 4;

  optional .k8s.io.api.core.v1.ResourceRequirements defaultResources = 5;
}

message GetVertexPodSpecReq {
  optional string isbSvcType = 1;

  optional string image = 2;

  optional string pullPolicy = 3;

  repeated .k8s.io.api.core.v1.EnvVar env = 4;

  optional string sideInputsStoreName = 5;

  optional string servingSourceStreamName = 6;

  optional PipelineSpec pipelineSpec = 7;

  optional .k8s.io.api.core.v1.ResourceRequirements defaultResources = 8;
}

// GroupBy indicates it is a reducer UDF
message GroupBy {
  // Window describes the windowing strategy.
  optional Window window = 1;

  // +optional
  optional bool keyed = 2;

  // AllowedLateness allows late data to be included for the Reduce operation as long as the late data is not later
  // than (Watermark - AllowedLateness).
  // +optional
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Duration allowedLateness = 3;

  // Storage is used to define the PBQ storage for a reduce vertex.
  optional PBQStorage storage = 4;
}

message HTTPSource {
  // +optional
  optional Authorization auth = 1;

  // Whether to create a ClusterIP Service
  // +optional
  optional bool service = 2;
}

message IdleSource {
  // Threshold is the duration after which a source is marked as Idle due to lack of data.
  // Ex: If watermark found to be idle after the Threshold duration then the watermark is progressed by `IncrementBy`.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Duration threshold = 1;

  // StepInterval is the duration between the subsequent increment of the watermark as long the source remains Idle.
  // The default value is 0s which means that once we detect idle source, we will be incrementing the watermark by
  // `IncrementBy` for time we detect that we source is empty (in other words, this will be a very frequent update).
  // +kubebuilder:default="0s"
  // +optional
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Duration stepInterval = 2;

  // IncrementBy is the duration to be added to the current watermark to progress the watermark when source is idling.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Duration incrementBy = 3;
}

// +genclient
// +kubebuilder:object:root=true
// +kubebuilder:resource:shortName=isbsvc
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Type",type=string,JSONPath=`.status.type`
// +kubebuilder:printcolumn:name="Phase",type=string,JSONPath=`.status.phase`
// +kubebuilder:printcolumn:name="Age",type=date,JSONPath=`.metadata.creationTimestamp`
// +kubebuilder:printcolumn:name="Message",type=string,JSONPath=`.status.message`
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +k8s:openapi-gen=true
message InterStepBufferService {
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional InterStepBufferServiceSpec spec = 2;

  // +optional
  optional InterStepBufferServiceStatus status = 3;
}

// InterStepBufferServiceList is the list of InterStepBufferService resources
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message InterStepBufferServiceList {
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated InterStepBufferService items = 2;
}

message InterStepBufferServiceSpec {
  optional RedisBufferService redis = 1;

  optional JetStreamBufferService jetstream = 2;
}

message InterStepBufferServiceStatus {
  optional Status status = 1;

  optional string phase = 2;

  optional string message = 3;

  optional BufferServiceConfig config = 4;

  optional string type = 5;

  optional int64 observedGeneration = 6;
}

message JetStreamBufferService {
  // JetStream version, such as "2.7.1"
  optional string version = 1;

  // JetStream StatefulSet size
  // +kubebuilder:default=3
  optional int32 replicas = 2;

  // ContainerTemplate contains customized spec for NATS container
  // +optional
  optional ContainerTemplate containerTemplate = 3;

  // ReloaderContainerTemplate contains customized spec for config reloader container
  // +optional
  optional ContainerTemplate reloaderContainerTemplate = 4;

  // MetricsContainerTemplate contains customized spec for metrics container
  // +optional
  optional ContainerTemplate metricsContainerTemplate = 5;

  // +optional
  optional PersistenceStrategy persistence = 6;

  // +optional
  optional AbstractPodTemplate abstractPodTemplate = 7;

  // Nats/JetStream configuration, if not specified, global settings in numaflow-controller-config will be used.
  // See https://docs.nats.io/running-a-nats-service/configuration#limits and https://docs.nats.io/running-a-nats-service/configuration#jetstream.
  // For limits, only "max_payload" is supported for configuration, defaults to 1048576 (1MB), not recommended to use values over 8388608 (8MB) but max_payload can be set up to 67108864 (64MB).
  // For jetstream, only "max_memory_store" and "max_file_store" are supported for configuration, do not set "store_dir" as it has been hardcoded.
  // +optional
  optional string settings = 8;

  // Optional arguments to start nats-server. For example, "-D" to enable debugging output, "-DV" to enable debugging and tracing.
  // Check https://docs.nats.io/ for all the available arguments.
  // +optional
  repeated string startArgs = 9;

  // Optional configuration for the streams, consumers and buckets to be created in this JetStream service, if specified, it will be merged with the default configuration in numaflow-controller-config.
  // It accepts a YAML format configuration, it may include 4 sections, "stream", "consumer", "otBucket" and "procBucket".
  // Available fields under "stream" include "retention" (e.g. interest, limits, workerQueue), "maxMsgs", "maxAge" (e.g. 72h), "replicas" (1, 3, 5), "duplicates" (e.g. 5m).
  // Available fields under "consumer" include "ackWait" (e.g. 60s)
  // Available fields under "otBucket" include "maxValueSize", "history", "ttl" (e.g. 72h), "maxBytes", "replicas" (1, 3, 5).
  // Available fields under "procBucket" include "maxValueSize", "history", "ttl" (e.g. 72h), "maxBytes", "replicas" (1, 3, 5).
  // +optional
  optional string bufferConfig = 10;

  // Whether encrypt the data at rest, defaults to false
  // Enabling encryption might impact the performance, see https://docs.nats.io/running-a-nats-service/nats_admin/jetstream_admin/encryption_at_rest for the detail
  // Toggling the value will impact encrypting/decrypting existing messages.
  // +optional
  optional bool encryption = 11;

  // Whether enable TLS, defaults to false
  // Enabling TLS might impact the performance
  // +optional
  optional bool tls = 12;
}

message JetStreamConfig {
  // JetStream (NATS) URL
  optional string url = 1;

  optional NatsAuth auth = 2;

  // +optional
  optional string streamConfig = 3;

  // TLS enabled or not
  optional bool tlsEnabled = 4;
}

message JetStreamSource {
  // URL to connect to NATS cluster, multiple urls could be separated by comma.
  optional string url = 1;

  // Stream represents the name of the stream.
  optional string stream = 2;

  // TLS configuration for the nats client.
  // +optional
  optional TLS tls = 3;

  // Auth information
  // +optional
  optional NatsAuth auth = 4;
}

message JobTemplate {
  // +optional
  optional AbstractPodTemplate abstractPodTemplate = 1;

  // +optional
  optional ContainerTemplate containerTemplate = 2;

  // ttlSecondsAfterFinished limits the lifetime of a Job that has finished
  // execution (either Complete or Failed). If this field is set,
  // ttlSecondsAfterFinished after the Job finishes, it is eligible to be
  // automatically deleted. When the Job is being deleted, its lifecycle
  // guarantees (e.g. finalizers) will be honored. If this field is unset,
  // the Job won't be automatically deleted. If this field is set to zero,
  // the Job becomes eligible to be deleted immediately after it finishes.
  // Numaflow defaults to 30
  // +optional
  optional int32 ttlSecondsAfterFinished = 3;

  // Specifies the number of retries before marking this job failed.
  // More info: https://kubernetes.io/docs/concepts/workloads/controllers/job/#pod-backoff-failure-policy
  // Numaflow defaults to 20
  // +optional
  optional int32 backoffLimit = 4;
}

message KafkaSink {
  repeated string brokers = 1;

  optional string topic = 2;

  // SetKey sets the Kafka key to the keys passed in the Message.
  // When the key is null (default), the record is sent randomly to one of the available partitions of the topic.
  // If a key exists, Kafka hashes the key, and the result is used to map the message to a specific partition. This
  // ensures that messages with the same key end up in the same partition.
  // +optional
  optional bool setKey = 3;

  // TLS user to configure TLS connection for kafka broker
  // TLS.enable=true default for TLS.
  // +optional
  optional TLS tls = 4;

  // +optional
  optional string config = 5;

  // SASL user to configure SASL connection for kafka broker
  // SASL.enable=true default for SASL.
  // +optional
  optional SASL sasl = 6;
}

message KafkaSource {
  repeated string brokers = 1;

  optional string topic = 2;

  optional string consumerGroup = 3;

  // TLS user to configure TLS connection for kafka broker
  // TLS.enable=true default for TLS.
  // +optional
  optional TLS tls = 4;

  // +optional
  optional string config = 5;

  // SASL user to configure SASL connection for kafka broker
  // SASL.enable=true default for SASL.
  // +optional
  optional SASL sasl = 6;

  optional string kafkaVersion = 7;
}

message Lifecycle {
  // DeletionGracePeriodSeconds used to delete pipeline gracefully
  // +kubebuilder:default=30
  // +optional
  optional int64 deletionGracePeriodSeconds = 1;

  // DesiredPhase used to bring the pipeline from current phase to desired phase
  // +kubebuilder:default=Running
  // +optional
  optional string desiredPhase = 2;

  // PauseGracePeriodSeconds used to pause pipeline gracefully
  // +kubebuilder:default=30
  // +optional
  optional int64 pauseGracePeriodSeconds = 3;

  // DeleteGracePeriodSeconds used to delete pipeline gracefully
  // +kubebuilder:default=30
  // Deprecated: Use DeletionGracePeriodSeconds instead
  // +optional
  optional int64 deleteGracePeriodSeconds = 4;
}

message Log {
}

message Metadata {
  map<string, string> annotations = 1;

  map<string, string> labels = 2;
}

// +genclient
// +kubebuilder:object:root=true
// +kubebuilder:resource:shortName=mvtx
// +kubebuilder:subresource:status
// +kubebuilder:subresource:scale:specpath=.spec.replicas,statuspath=.status.replicas,selectorpath=.status.selector
// +kubebuilder:printcolumn:name="Phase",type=string,JSONPath=`.status.phase`
// +kubebuilder:printcolumn:name="Desired",type=string,JSONPath=`.status.desiredReplicas`
// +kubebuilder:printcolumn:name="Current",type=string,JSONPath=`.status.replicas`
// +kubebuilder:printcolumn:name="Ready",type=string,JSONPath=`.status.readyReplicas`
// +kubebuilder:printcolumn:name="Age",type=date,JSONPath=`.metadata.creationTimestamp`
// +kubebuilder:printcolumn:name="Reason",type=string,JSONPath=`.status.reason`
// +kubebuilder:printcolumn:name="Message",type=string,JSONPath=`.status.message`
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +k8s:openapi-gen=true
message MonoVertex {
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional MonoVertexSpec spec = 2;

  // +optional
  optional MonoVertexStatus status = 3;
}

message MonoVertexLifecycle {
  // DesiredPhase used to bring the pipeline from current phase to desired phase
  // +kubebuilder:default=Running
  // +optional
  optional string desiredPhase = 1;
}

message MonoVertexLimits {
  // Read batch size from the source.
  // +kubebuilder:default=500
  // +optional
  optional uint64 readBatchSize = 1;

  // Read timeout duration from the source.
  // +kubebuilder:default= "1s"
  // +optional
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Duration readTimeout = 2;
}

// +kubebuilder:object:root=true
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message MonoVertexList {
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated MonoVertex items = 2;
}

message MonoVertexSpec {
  // +kubebuilder:default=1
  // +optional
  optional int32 replicas = 1;

  optional Source source = 2;

  optional Sink sink = 3;

  // +optional
  optional AbstractPodTemplate abstractPodTemplate = 4;

  // Container template for the main numa container.
  // +optional
  optional ContainerTemplate containerTemplate = 5;

  // +optional
  // +patchStrategy=merge
  // +patchMergeKey=name
  repeated .k8s.io.api.core.v1.Volume volumes = 6;

  // Limits define the limitations such as read batch size for the mono vertex.
  // +optional
  optional MonoVertexLimits limits = 7;

  // Settings for autoscaling
  // +optional
  optional Scale scale = 8;

  // List of customized init containers belonging to the pod.
  // More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
  // +optional
  repeated .k8s.io.api.core.v1.Container initContainers = 9;

  // List of customized sidecar containers belonging to the pod.
  // +optional
  repeated .k8s.io.api.core.v1.Container sidecars = 10;

  // Template for the daemon service deployment.
  // +optional
  optional DaemonTemplate daemonTemplate = 11;

  // The strategy to use to replace existing pods with new ones.
  // +kubebuilder:default={"type": "RollingUpdate", "rollingUpdate": {"maxUnavailable": "25%"}}
  // +optional
  optional UpdateStrategy updateStrategy = 12;

  // Lifecycle defines the Lifecycle properties of a MonoVertex
  // +kubebuilder:default={"desiredPhase": Running}
  // +optional
  optional MonoVertexLifecycle lifecycle = 13;
}

message MonoVertexStatus {
  optional Status status = 1;

  // +optional
  optional string phase = 2;

  // Total number of non-terminated pods targeted by this MonoVertex (their labels match the selector).
  // +optional
  optional uint32 replicas = 3;

  // The number of desired replicas.
  // +optional
  optional uint32 desiredReplicas = 4;

  // +optional
  optional string selector = 5;

  // +optional
  optional string reason = 6;

  // +optional
  optional string message = 7;

  // +optional
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastUpdated = 8;

  // Time of last scaling operation.
  // +optional
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastScaledAt = 9;

  // The generation observed by the MonoVertex controller.
  // +optional
  optional int64 observedGeneration = 10;

  // The number of pods targeted by this MonoVertex with a Ready Condition.
  // +optional
  optional uint32 readyReplicas = 11;

  // The number of Pods created by the controller from the MonoVertex version indicated by updateHash.
  optional uint32 updatedReplicas = 12;

  // The number of ready Pods created by the controller from the MonoVertex version indicated by updateHash.
  optional uint32 updatedReadyReplicas = 13;

  // If not empty, indicates the current version of the MonoVertex used to generate Pods.
  optional string currentHash = 14;

  // If not empty, indicates the updated version of the MonoVertex used to generate Pods.
  optional string updateHash = 15;
}

message NativeRedis {
  // Redis version, such as "6.0.16"
  optional string version = 1;

  // Redis StatefulSet size
  // +kubebuilder:default=3
  optional int32 replicas = 2;

  // RedisContainerTemplate contains customized spec for Redis container
  // +optional
  optional ContainerTemplate redisContainerTemplate = 3;

  // SentinelContainerTemplate contains customized spec for Redis container
  // +optional
  optional ContainerTemplate sentinelContainerTemplate = 4;

  // MetricsContainerTemplate contains customized spec for metrics container
  // +optional
  optional ContainerTemplate metricsContainerTemplate = 5;

  // +optional
  optional ContainerTemplate initContainerTemplate = 6;

  // +optional
  optional PersistenceStrategy persistence = 7;

  // +optional
  optional AbstractPodTemplate abstractPodTemplate = 8;

  // Redis configuration, if not specified, global settings in numaflow-controller-config will be used.
  // +optional
  optional RedisSettings settings = 9;
}

// NatsAuth defines how to authenticate the nats access
message NatsAuth {
  // Basic auth which contains a username and a password
  // +optional
  optional BasicAuth basic = 1;

  // Token auth
  // +optional
  optional .k8s.io.api.core.v1.SecretKeySelector token = 2;

  // NKey auth
  // +optional
  optional .k8s.io.api.core.v1.SecretKeySelector nkey = 3;
}

message NatsSource {
  // URL to connect to NATS cluster, multiple urls could be separated by comma.
  optional string url = 1;

  // Subject holds the name of the subject onto which messages are published.
  optional string subject = 2;

  // Queue is used for queue subscription.
  optional string queue = 3;

  // TLS configuration for the nats client.
  // +optional
  optional TLS tls = 4;

  // Auth information
  // +optional
  optional NatsAuth auth = 5;
}

// NoStore means there will be no persistence storage and there will be data loss during pod restarts.
// Use this option only if you do not care about correctness (e.g., approx statistics pipeline like sampling rate, etc.).
message NoStore {
}

// PBQStorage defines the persistence configuration for a vertex.
message PBQStorage {
  // +optional
  optional PersistenceStrategy persistentVolumeClaim = 1;

  // +optional
  optional .k8s.io.api.core.v1.EmptyDirVolumeSource emptyDir = 2;

  // +optional
  optional NoStore no_store = 3;
}

// PersistenceStrategy defines the strategy of persistence
message PersistenceStrategy {
  // Name of the StorageClass required by the claim.
  // More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
  // +optional
  optional string storageClassName = 1;

  // Available access modes such as ReadWriteOnce, ReadWriteMany
  // https://kubernetes.io/docs/concepts/storage/persistent-volumes/#access-modes
  // +optional
  optional string accessMode = 2;

  // Volume size, e.g. 50Gi
  optional .k8s.io.apimachinery.pkg.api.resource.Quantity volumeSize = 3;
}

// +genclient
// +kubebuilder:object:root=true
// +kubebuilder:resource:shortName=pl
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Phase",type=string,JSONPath=`.status.phase`
// +kubebuilder:printcolumn:name="Vertices",type=integer,JSONPath=`.status.vertexCount`
// +kubebuilder:printcolumn:name="Sources",type=integer,JSONPath=`.status.sourceCount`,priority=10
// +kubebuilder:printcolumn:name="Sinks",type=integer,JSONPath=`.status.sinkCount`,priority=10
// +kubebuilder:printcolumn:name="UDFs",type=integer,JSONPath=`.status.udfCount`,priority=10
// +kubebuilder:printcolumn:name="Map UDFs",type=integer,JSONPath=`.status.mapUDFCount`,priority=10
// +kubebuilder:printcolumn:name="Reduce UDFs",type=integer,JSONPath=`.status.reduceUDFCount`,priority=10
// +kubebuilder:printcolumn:name="Age",type=date,JSONPath=`.metadata.creationTimestamp`
// +kubebuilder:printcolumn:name="Message",type=string,JSONPath=`.status.message`
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +k8s:openapi-gen=true
message Pipeline {
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional PipelineSpec spec = 2;

  // +optional
  optional PipelineStatus status = 3;
}

message PipelineLimits {
  // Read batch size for all the vertices in the pipeline, can be overridden by the vertex's limit settings.
  // +kubebuilder:default=500
  // +optional
  optional uint64 readBatchSize = 1;

  // BufferMaxLength is used to define the max length of a buffer.
  // Only applies to UDF and Source vertices as only they do buffer write.
  // It can be overridden by the settings in vertex limits.
  // +kubebuilder:default=30000
  // +optional
  optional uint64 bufferMaxLength = 2;

  // BufferUsageLimit is used to define the percentage of the buffer usage limit, a valid value should be less than 100, for example, 85.
  // Only applies to UDF and Source vertices as only they do buffer write.
  // It will be overridden by the settings in vertex limits.
  // +kubebuilder:default=80
  // +optional
  optional uint32 bufferUsageLimit = 3;

  // Read timeout for all the vertices in the pipeline, can be overridden by the vertex's limit settings
  // +kubebuilder:default= "1s"
  // +optional
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Duration readTimeout = 4;
}

// +kubebuilder:object:root=true
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message PipelineList {
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated Pipeline items = 2;
}

message PipelineSpec {
  // +optional
  optional string interStepBufferServiceName = 1;

  // +patchStrategy=merge
  // +patchMergeKey=name
  repeated AbstractVertex vertices = 2;

  // Edges define the relationships between vertices
  repeated Edge edges = 3;

  // Lifecycle define the Lifecycle properties
  // +kubebuilder:default={"deleteGracePeriodSeconds": 30, "desiredPhase": Running, "pauseGracePeriodSeconds": 30}
  // +optional
  optional Lifecycle lifecycle = 4;

  // Limits define the limitations such as buffer read batch size for all the vertices of a pipeline, they could be overridden by each vertex's settings
  // +kubebuilder:default={"readBatchSize": 500, "bufferMaxLength": 30000, "bufferUsageLimit": 80}
  // +optional
  optional PipelineLimits limits = 5;

  // Watermark enables watermark progression across the entire pipeline.
  // +kubebuilder:default={"disabled": false}
  // +optional
  optional Watermark watermark = 6;

  // Templates are used to customize additional kubernetes resources required for the Pipeline
  // +optional
  optional Templates templates = 7;

  // SideInputs defines the Side Inputs of a pipeline.
  // +optional
  repeated SideInput sideInputs = 8;
}

message PipelineStatus {
  optional Status status = 1;

  // +optional
  optional string phase = 2;

  // +optional
  optional string message = 3;

  // +optional
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastUpdated = 4;

  // +optional
  optional uint32 vertexCount = 5;

  // +optional
  optional uint32 sourceCount = 6;

  // +optional
  optional uint32 sinkCount = 7;

  // +optional
  optional uint32 udfCount = 8;

  // +optional
  optional uint32 mapUDFCount = 9;

  // +optional
  optional uint32 reduceUDFCount = 10;

  // The generation observed by the Pipeline controller.
  // +optional
  optional int64 observedGeneration = 11;

  // Field to indicate if a pipeline drain successfully occurred, only meaningful when the pipeline is paused.
  // True means it has been successfully drained.
  // +optional
  optional bool drainedOnPause = 12;
}

// Probe is used to customize the configuration for Readiness and Liveness probes.
message Probe {
  // Number of seconds after the container has started before liveness probes are initiated.
  // More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
  // +optional
  optional int32 initialDelaySeconds = 1;

  // Number of seconds after which the probe times out.
  // More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
  // +optional
  optional int32 timeoutSeconds = 2;

  // How often (in seconds) to perform the probe.
  // +optional
  optional int32 periodSeconds = 3;

  // Minimum consecutive successes for the probe to be considered successful after having failed.
  // Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
  // +optional
  optional int32 successThreshold = 4;

  // Minimum consecutive failures for the probe to be considered failed after having succeeded.
  // Defaults to 3. Minimum value is 1.
  // +optional
  optional int32 failureThreshold = 5;
}

message RedisBufferService {
  // Native brings up a native Redis service
  optional NativeRedis native = 1;

  // External holds an External Redis config
  optional RedisConfig external = 2;
}

message RedisConfig {
  // Redis URL
  // +optional
  optional string url = 1;

  // Sentinel URL, will be ignored if Redis URL is provided
  // +optional
  optional string sentinelUrl = 2;

  // Only required when Sentinel is used
  // +optional
  optional string masterName = 3;

  // Redis user
  // +optional
  optional string user = 4;

  // Redis password secret selector
  // +optional
  optional .k8s.io.api.core.v1.SecretKeySelector password = 5;

  // Sentinel password secret selector
  // +optional
  optional .k8s.io.api.core.v1.SecretKeySelector sentinelPassword = 6;
}

message RedisSettings {
  // Redis settings shared by both master and slaves, will override the global settings from controller config
  // +optional
  optional string redis = 1;

  // Special settings for Redis master node, will override the global settings from controller config
  // +optional
  optional string master = 2;

  // Special settings for Redis replica nodes, will override the global settings from controller config
  // +optional
  optional string replica = 3;

  // Sentinel settings, will override the global settings from controller config
  // +optional
  optional string sentinel = 4;
}

// RetryStrategy struct encapsulates the settings for retrying operations in the event of failures.
// It includes a BackOff strategy to manage the timing of retries and defines the action to take upon failure.
message RetryStrategy {
  // BackOff specifies the parameters for the backoff strategy, controlling how delays between retries should increase.
  // +optional
  optional Backoff backoff = 1;

  // OnFailure specifies the action to take when a retry fails. The default action is to retry.
  // +optional
  // +kubebuilder:default="retry"
  optional string onFailure = 2;
}

// RollingUpdateStrategy is used to communicate parameter for RollingUpdateStrategyType.
message RollingUpdateStrategy {
  // The maximum number of pods that can be unavailable during the update.
  // Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
  // Absolute number is calculated from percentage by rounding down.
  // Defaults to 25%.
  // Example: when this is set to 30%, the old pods can be scaled down to 70% of desired pods
  // immediately when the rolling update starts. Once new pods are ready, old pods
  // can be scaled down further, followed by scaling up the new pods, ensuring
  // that the total number of pods available at all times during the update is at
  // least 70% of desired pods.
  // +optional
  optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;
}

message SASL {
  // SASL mechanism to use
  optional string mechanism = 1;

  // GSSAPI contains the kerberos config
  // +optional
  optional GSSAPI gssapi = 2;

  // SASLPlain contains the sasl plain config
  // +optional
  optional SASLPlain plain = 3;

  // SASLSCRAMSHA256 contains the sasl plain config
  // +optional
  optional SASLPlain scramsha256 = 4;

  // SASLSCRAMSHA512 contains the sasl plain config
  // +optional
  optional SASLPlain scramsha512 = 5;
}

message SASLPlain {
  // UserSecret refers to the secret that contains the user
  optional .k8s.io.api.core.v1.SecretKeySelector userSecret = 1;

  // PasswordSecret refers to the secret that contains the password
  // +optional
  optional .k8s.io.api.core.v1.SecretKeySelector passwordSecret = 2;

  optional bool handshake = 3;
}

// Scale defines the parameters for autoscaling.
message Scale {
  // Whether to disable autoscaling.
  // Set to "true" when using Kubernetes HPA or any other 3rd party autoscaling strategies.
  // +optional
  optional bool disabled = 1;

  // Minimum replicas.
  // +optional
  optional int32 min = 2;

  // Maximum replicas.
  // +optional
  optional int32 max = 3;

  // Lookback seconds to calculate the average pending messages and processing rate.
  // +optional
  optional uint32 lookbackSeconds = 4;

  // After scaling down the source vertex to 0, sleep how many seconds before scaling the source vertex back up to peek.
  // +optional
  optional uint32 zeroReplicaSleepSeconds = 5;

  // TargetProcessingSeconds is used to tune the aggressiveness of autoscaling for source vertices, it measures how fast
  // you want the vertex to process all the pending messages. Typically increasing the value, which leads to lower processing
  // rate, thus less replicas. It's only effective for source vertices.
  // +optional
  optional uint32 targetProcessingSeconds = 6;

  // TargetBufferAvailability is used to define the target percentage of the buffer availability.
  // A valid and meaningful value should be less than the BufferUsageLimit defined in the Edge spec (or Pipeline spec), for example, 50.
  // It only applies to UDF and Sink vertices because only they have buffers to read.
  // +optional
  optional uint32 targetBufferAvailability = 7;

  // DeprecatedReplicasPerScale defines the number of maximum replicas that can be changed in a single scale up or down operation.
  // The is use to prevent from too aggressive scaling operations
  // Deprecated: Use ReplicasPerScaleUp and ReplicasPerScaleDown instead
  // +optional
  optional uint32 replicasPerScale = 8;

  // ScaleUpCooldownSeconds defines the cooldown seconds after a scaling operation, before a follow-up scaling up.
  // It defaults to the CooldownSeconds if not set.
  // +optional
  optional uint32 scaleUpCooldownSeconds = 9;

  // ScaleDownCooldownSeconds defines the cooldown seconds after a scaling operation, before a follow-up scaling down.
  // It defaults to the CooldownSeconds if not set.
  // +optional
  optional uint32 scaleDownCooldownSeconds = 10;

  // ReplicasPerScaleUp defines the number of maximum replicas that can be changed in a single scaled up operation.
  // The is use to prevent from too aggressive scaling up operations
  // +optional
  optional uint32 replicasPerScaleUp = 11;

  // ReplicasPerScaleDown defines the number of maximum replicas that can be changed in a single scaled down operation.
  // The is use to prevent from too aggressive scaling down operations
  // +optional
  optional uint32 replicasPerScaleDown = 12;
}

// ServingSource is the HTTP endpoint for Numaflow.
message ServingSource {
  // +optional
  optional Authorization auth = 1;

  // Whether to create a ClusterIP Service
  // +optional
  optional bool service = 2;

  // The header key from which the message id will be extracted
  optional string msgIDHeaderKey = 3;

  // Persistent store for the callbacks for serving and tracking
  optional ServingStore store = 4;
}

// ServingStore to track and store data and metadata for tracking and serving.
message ServingStore {
  // URL of the persistent store to write the callbacks
  optional string url = 1;

  // TTL for the data in the store and tracker
  // +optional
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Duration ttl = 2;
}

// SessionWindow describes a session window
message SessionWindow {
  // Timeout is the duration of inactivity after which a session window closes.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Duration timeout = 1;
}

// SideInput defines information of a Side Input
message SideInput {
  optional string name = 1;

  optional Container container = 2;

  // +optional
  // +patchStrategy=merge
  // +patchMergeKey=name
  repeated .k8s.io.api.core.v1.Volume volumes = 3;

  optional SideInputTrigger trigger = 4;
}

message SideInputTrigger {
  // The schedule to trigger the retrievement of the side input data.
  // It supports cron format, for example, "0 30 * * * *".
  // Or interval based format, such as "@hourly", "@every 1h30m", etc.
  optional string schedule = 1;

  // +optional
  optional string timezone = 2;
}

message SideInputsManagerTemplate {
  // +optional
  optional AbstractPodTemplate abstractPodTemplate = 1;

  // Template for the side inputs manager numa container
  // +optional
  optional ContainerTemplate containerTemplate = 2;

  // Template for the side inputs manager init container
  // +optional
  optional ContainerTemplate initContainerTemplate = 3;
}

message Sink {
  optional AbstractSink abstractSink = 1;

  // Fallback sink can be imagined as DLQ for primary Sink. The writes to Fallback sink will only be
  // initiated if the ud-sink response field sets it.
  // +optional
  optional AbstractSink fallback = 2;

  // RetryStrategy struct encapsulates the settings for retrying operations in the event of failures.
  // +optional
  optional RetryStrategy retryStrategy = 3;
}

// SlidingWindow describes a sliding window
message SlidingWindow {
  // Length is the duration of the sliding window.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Duration length = 1;

  // Slide is the slide parameter that controls the frequency at which the sliding window is created.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Duration slide = 2;

  // +optional
  // Streaming should be set to true if the reduce udf is streaming.
  optional bool streaming = 3;
}

message Source {
  // +optional
  optional GeneratorSource generator = 1;

  // +optional
  optional KafkaSource kafka = 2;

  // +optional
  optional HTTPSource http = 3;

  // +optional
  optional NatsSource nats = 4;

  // +optional
  optional UDTransformer transformer = 5;

  // +optional
  optional UDSource udSource = 6;

  // +optional
  optional JetStreamSource jetstream = 7;

  // +optional
  optional ServingSource serving = 8;
}

// Status is a common structure which can be used for Status field.
message Status {
  // Conditions are the latest available observations of a resource's current state.
  // +optional
  // +patchMergeKey=type
  // +patchStrategy=merge
  repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 1;
}

message TLS {
  // +optional
  optional bool insecureSkipVerify = 1;

  // CACertSecret refers to the secret that contains the CA cert
  // +optional
  optional .k8s.io.api.core.v1.SecretKeySelector caCertSecret = 2;

  // CertSecret refers to the secret that contains the cert
  // +optional
  optional .k8s.io.api.core.v1.SecretKeySelector certSecret = 3;

  // KeySecret refers to the secret that contains the key
  // +optional
  optional .k8s.io.api.core.v1.SecretKeySelector keySecret = 4;
}

message TagConditions {
  // Operator specifies the type of operation that should be used for conditional forwarding
  // value could be "and", "or", "not"
  // +kubebuilder:validation:Enum=and;or;not
  // +optional
  optional string operator = 1;

  // Values tag values for conditional forwarding
  repeated string values = 2;
}

message Templates {
  // DaemonTemplate is used to customize the Daemon Deployment.
  // +optional
  optional DaemonTemplate daemon = 1;

  // JobTemplate is used to customize Jobs.
  // +optional
  optional JobTemplate job = 2;

  // SideInputsManagerTemplate is used to customize the Side Inputs Manager.
  // +optional
  optional SideInputsManagerTemplate sideInputsManager = 3;

  // VertexTemplate is used to customize the vertices of the pipeline.
  // +optional
  optional VertexTemplate vertex = 4;
}

message Transformer {
  // +kubebuilder:validation:Enum=eventTimeExtractor;filter;timeExtractionFilter
  optional string name = 1;

  // +optional
  repeated string args = 2;

  // +optional
  map<string, string> kwargs = 3;
}

message UDF {
  // +optional
  optional Container container = 1;

  // +optional
  optional Function builtin = 2;

  // +optional
  optional GroupBy groupBy = 3;
}

message UDSink {
  optional Container container = 1;
}

message UDSource {
  optional Container container = 1;
}

message UDTransformer {
  // +optional
  optional Container container = 1;

  // +optional
  optional Transformer builtin = 2;
}

// UpdateStrategy indicates the strategy that the
// controller will use to perform updates for Vertex or MonoVertex.
message UpdateStrategy {
  // Type indicates the type of the StatefulSetUpdateStrategy.
  // Default is RollingUpdate.
  // +optional
  optional string type = 1;

  // RollingUpdate is used to communicate parameters when Type is RollingUpdateStrategy.
  // +optional
  optional RollingUpdateStrategy rollingUpdate = 2;
}

// +genclient
// +kubebuilder:object:root=true
// +kubebuilder:resource:shortName=vtx
// +kubebuilder:subresource:status
// +kubebuilder:subresource:scale:specpath=.spec.replicas,statuspath=.status.replicas,selectorpath=.status.selector
// +kubebuilder:printcolumn:name="Phase",type=string,JSONPath=`.status.phase`
// +kubebuilder:printcolumn:name="Desired",type=string,JSONPath=`.status.desiredReplicas`
// +kubebuilder:printcolumn:name="Current",type=string,JSONPath=`.status.replicas`
// +kubebuilder:printcolumn:name="Ready",type=string,JSONPath=`.status.readyReplicas`
// +kubebuilder:printcolumn:name="Age",type=date,JSONPath=`.metadata.creationTimestamp`
// +kubebuilder:printcolumn:name="Reason",type=string,JSONPath=`.status.reason`
// +kubebuilder:printcolumn:name="Message",type=string,JSONPath=`.status.message`
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +k8s:openapi-gen=true
message Vertex {
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional VertexSpec spec = 2;

  // +optional
  optional VertexStatus status = 3;
}

// VertexInstance is a wrapper of a vertex instance, which contains the vertex spec and the instance information such as hostname and replica index.
message VertexInstance {
  optional Vertex vertex = 1;

  optional string hostname = 2;

  optional int32 replica = 3;
}

message VertexLimits {
  // Read batch size from the source or buffer.
  // It overrides the settings from pipeline limits.
  // +optional
  optional uint64 readBatchSize = 1;

  // Read timeout duration from the source or buffer
  // It overrides the settings from pipeline limits.
  // +optional
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Duration readTimeout = 2;

  // BufferMaxLength is used to define the max length of a buffer.
  // It overrides the settings from pipeline limits.
  // +optional
  optional uint64 bufferMaxLength = 3;

  // BufferUsageLimit is used to define the percentage of the buffer usage limit, a valid value should be less than 100, for example, 85.
  // It overrides the settings from pipeline limits.
  // +optional
  optional uint32 bufferUsageLimit = 4;
}

// +kubebuilder:object:root=true
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message VertexList {
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated Vertex items = 2;
}

message VertexSpec {
  optional AbstractVertex abstractVertex = 1;

  optional string pipelineName = 2;

  // +optional
  optional string interStepBufferServiceName = 3;

  // +kubebuilder:default=1
  // +optional
  optional int32 replicas = 4;

  // +optional
  repeated CombinedEdge fromEdges = 5;

  // +optional
  repeated CombinedEdge toEdges = 6;

  // Watermark indicates watermark progression in the vertex, it's populated from the pipeline watermark settings.
  // +kubebuilder:default={"disabled": false}
  // +optional
  optional Watermark watermark = 7;
}

message VertexStatus {
  optional Status status = 1;

  // +optional
  optional string phase = 2;

  // Total number of non-terminated pods targeted by this Vertex (their labels match the selector).
  // +optional
  optional uint32 replicas = 3;

  // The number of desired replicas.
  // +optional
  optional uint32 desiredReplicas = 4;

  // +optional
  optional string selector = 5;

  // +optional
  optional string reason = 6;

  // +optional
  optional string message = 7;

  // Time of last scaling operation.
  // +optional
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastScaledAt = 8;

  // The generation observed by the Vertex controller.
  // +optional
  optional int64 observedGeneration = 9;

  // The number of pods targeted by this Vertex with a Ready Condition.
  // +optional
  optional uint32 readyReplicas = 10;

  // The number of Pods created by the controller from the Vertex version indicated by updateHash.
  optional uint32 updatedReplicas = 11;

  // The number of ready Pods created by the controller from the Vertex version indicated by updateHash.
  optional uint32 updatedReadyReplicas = 12;

  // If not empty, indicates the current version of the Vertex used to generate Pods.
  optional string currentHash = 13;

  // If not empty, indicates the updated version of the Vertex used to generate Pods.
  optional string updateHash = 14;
}

message VertexTemplate {
  // +optional
  optional AbstractPodTemplate abstractPodTemplate = 1;

  // Template for the vertex numa container
  // +optional
  optional ContainerTemplate containerTemplate = 2;

  // Template for the vertex init container
  // +optional
  optional ContainerTemplate initContainerTemplate = 3;
}

message Watermark {
  // Disabled toggles the watermark propagation, defaults to false.
  // +kubebuilder:default=false
  // +optional
  optional bool disabled = 1;

  // Maximum delay allowed for watermark calculation, defaults to "0s", which means no delay.
  // +kubebuilder:default="0s"
  // +optional
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Duration maxDelay = 2;

  // IdleSource defines the idle watermark properties, it could be configured in case source is idling.
  // +optional
  optional IdleSource idleSource = 3;
}

// Window describes windowing strategy
message Window {
  // +optional
  optional FixedWindow fixed = 1;

  // +optional
  optional SlidingWindow sliding = 2;

  // +optional
  optional SessionWindow session = 3;
}

