/*
Copyright 2022 The Numaproj Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/


// This file was autogenerated by go-to-protobuf. Do not edit it manually!

syntax = "proto2";

package github.com.numaproj.numaflow.pkg.apis.numaflow.v1alpha1;

import "k8s.io/api/core/v1/generated.proto";
import "k8s.io/apimachinery/pkg/api/resource/generated.proto";
import "k8s.io/apimachinery/pkg/apis/meta/v1/generated.proto";
import "k8s.io/apimachinery/pkg/runtime/generated.proto";
import "k8s.io/apimachinery/pkg/runtime/schema/generated.proto";

// Package-wide variables from generator "generated".
option go_package = "v1alpha1";

// AbstractPodTemplate provides a template for pod customization in vertices, daemon deployments and so on.
message AbstractPodTemplate {
  // Metadata sets the pods's metadata, i.e. annotations and labels
  // +optional
  optional Metadata metadata = 1;

  // NodeSelector is a selector which must be true for the pod to fit on a node.
  // Selector which must match a node's labels for the pod to be scheduled on that node.
  // More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
  // +optional
  map<string, string> nodeSelector = 2;

  // If specified, the pod's tolerations.
  // +optional
  repeated k8s.io.api.core.v1.Toleration tolerations = 3;

  // SecurityContext holds pod-level security attributes and common container settings.
  // Optional: Defaults to empty.  See type description for default values of each field.
  // +optional
  optional k8s.io.api.core.v1.PodSecurityContext securityContext = 4;

  // ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec.
  // If specified, these secrets will be passed to individual puller implementations for them to use. For example,
  // in the case of docker, only DockerConfig type secrets are honored.
  // More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod
  // +optional
  // +patchMergeKey=name
  // +patchStrategy=merge
  repeated k8s.io.api.core.v1.LocalObjectReference imagePullSecrets = 5;

  // If specified, indicates the Redis pod's priority. "system-node-critical"
  // and "system-cluster-critical" are two special keywords which indicate the
  // highest priorities with the former being the highest priority. Any other
  // name must be defined by creating a PriorityClass object with that name.
  // If not specified, the pod priority will be default or zero if there is no
  // default.
  // More info: https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/
  // +optional
  optional string priorityClassName = 6;

  // The priority value. Various system components use this field to find the
  // priority of the Redis pod. When Priority Admission Controller is enabled,
  // it prevents users from setting this field. The admission controller populates
  // this field from PriorityClassName.
  // The higher the value, the higher the priority.
  // More info: https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/
  // +optional
  optional int32 priority = 7;

  // The pod's scheduling constraints
  // More info: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/
  // +optional
  optional k8s.io.api.core.v1.Affinity affinity = 8;

  // ServiceAccountName applied to the pod
  // +optional
  optional string serviceAccountName = 9;
}

message AbstractVertex {
  optional string name = 1;

  // +optional
  optional Source source = 2;

  // +optional
  optional Sink sink = 3;

  // +optional
  optional UDF udf = 4;

  // +optional
  optional ContainerTemplate containerTemplate = 5;

  // +optional
  optional ContainerTemplate initContainerTemplate = 6;

  // +optional
  optional AbstractPodTemplate abstractPodTemplate = 7;

  // +optional
  // +patchStrategy=merge
  // +patchMergeKey=name
  repeated k8s.io.api.core.v1.Volume volumes = 8;

  // Limits define the limitations such as buffer read batch size for all the vertices of a pipeline, will override pipeline level settings
  // +optional
  optional VertexLimits limits = 9;

  // Settings for autoscaling
  // +optional
  optional Scale scale = 10;

  // List of init containers belonging to the pod.
  // More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
  // +optional
  repeated k8s.io.api.core.v1.Container initContainers = 11;
}

message Authorization {
  // A secret selector which contains bearer token
  // To use this, the client needs to add "Authorization: Bearer <token>" in the header
  // +optional
  optional k8s.io.api.core.v1.SecretKeySelector token = 1;
}

message Buffer {
  optional string name = 1;

  optional string type = 2;
}

message BufferServiceConfig {
  optional RedisConfig redis = 1;

  optional JetStreamConfig jetstream = 2;
}

message Container {
  // +optional
  optional string image = 1;

  // +optional
  repeated string command = 2;

  // +optional
  repeated string args = 3;

  // +optional
  repeated k8s.io.api.core.v1.EnvVar env = 4;

  // +optional
  repeated k8s.io.api.core.v1.VolumeMount volumeMounts = 5;

  // +optional
  optional k8s.io.api.core.v1.ResourceRequirements resources = 6;
}

// ContainerTemplate defines customized spec for a container
message ContainerTemplate {
  optional k8s.io.api.core.v1.ResourceRequirements resources = 1;

  optional string imagePullPolicy = 2;

  optional k8s.io.api.core.v1.SecurityContext securityContext = 3;

  repeated k8s.io.api.core.v1.EnvVar env = 4;
}

message DaemonTemplate {
  // +optional
  optional AbstractPodTemplate abstractPodTemplate = 1;

  // Replicas is the number of desired replicas of the Deployment.
  // This is a pointer to distinguish between explicit zero and unspecified.
  // Defaults to 1.
  // More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#what-is-a-replicationcontroller
  // +optional
  optional int32 replicas = 2;

  // +optional
  optional ContainerTemplate containerTemplate = 3;

  // +optional
  optional ContainerTemplate initContainerTemplate = 4;
}

message Edge {
  optional string from = 1;

  optional string to = 2;

  // Conditional forwarding, only allowed when "From" is a Sink or UDF.
  // +optional
  optional ForwardConditions conditions = 3;

  // Limits define the limitations such as buffer read batch size for the edge, will override pipeline level settings.
  // +optional
  optional EdgeLimits limits = 4;

  // Parallelism is only effective when the "to" vertex is a reduce vertex,
  // if it's provided, the default value is set to "1".
  // Parallelism is ignored when the "to" vertex is not a reduce vertex.
  // +optional
  optional int32 parallelism = 5;
}

message EdgeLimits {
  // BufferMaxLength is used to define the max length of a buffer.
  // It overrides the settings from pipeline limits.
  // +optional
  optional uint64 bufferMaxLength = 1;

  // BufferUsageLimit is used to define the percentage of the buffer usage limit, a valid value should be less than 100, for example, 85.
  // It overrides the settings from pipeline limits.
  // +optional
  optional uint32 bufferUsageLimit = 2;
}

// FixedWindow describes a fixed window
message FixedWindow {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Duration length = 1;
}

message ForwardConditions {
  repeated string keyIn = 1;
}

message Function {
  // +kubebuilder:validation:Enum=cat;filter
  optional string name = 1;

  // +optional
  repeated string args = 2;

  // +optional
  map<string, string> kwargs = 3;
}

message GeneratorSource {
  // +kubebuilder:default=5
  // +optional
  optional int64 rpu = 1;

  // +kubebuilder:default="1s"
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Duration duration = 2;

  // Size of each generated message
  // +kubebuilder:default=8
  // +optional
  optional int32 msgSize = 3;
}

message GetDaemonDeploymentReq {
  optional string isbSvcType = 1;

  optional string image = 2;

  optional string pullPolicy = 3;

  repeated k8s.io.api.core.v1.EnvVar env = 4;
}

message GetJetStreamServiceSpecReq {
  map<string, string> labels = 1;

  optional int32 clusterPort = 2;

  optional int32 clientPort = 3;

  optional int32 monitorPort = 4;

  optional int32 metricsPort = 5;
}

message GetJetStreamStatefulSetSpecReq {
  optional string serviceName = 1;

  map<string, string> labels = 2;

  optional string natsImage = 3;

  optional string metricsExporterImage = 4;

  optional string configReloaderImage = 5;

  optional int32 clusterPort = 6;

  optional int32 clientPort = 7;

  optional int32 monitorPort = 8;

  optional int32 metricsPort = 9;

  optional string serverAuthSecretName = 10;

  optional string serverEncryptionSecretName = 11;

  optional string configMapName = 12;

  optional string pvcNameIfNeeded = 13;

  optional string startCommand = 14;
}

message GetRedisServiceSpecReq {
  map<string, string> labels = 1;

  optional int32 redisContainerPort = 2;

  optional int32 sentinelContainerPort = 3;
}

message GetRedisStatefulSetSpecReq {
  optional string serviceName = 1;

  map<string, string> labels = 2;

  optional string redisImage = 3;

  optional string sentinelImage = 4;

  optional string metricsExporterImage = 5;

  optional string initContainerImage = 6;

  optional int32 redisContainerPort = 7;

  optional int32 sentinelContainerPort = 8;

  optional int32 redisMetricsContainerPort = 9;

  optional string credentialSecretName = 10;

  optional bool tlsEnabled = 11;

  optional string pvcNameIfNeeded = 12;

  optional string confConfigMapName = 13;

  optional string scriptsConfigMapName = 14;

  optional string healthConfigMapName = 15;
}

message GetVertexPodSpecReq {
  optional string isbSvcType = 1;

  optional string image = 2;

  optional string pullPolicy = 3;

  repeated k8s.io.api.core.v1.EnvVar env = 4;
}

// GroupBy indicates it is a reducer UDF
message GroupBy {
  // Window describes the windowing strategy.
  optional Window window = 1;

  // +optional
  optional bool keyed = 2;

  // Storage is used to define the PBQ storage for a reduce vertex.
  // +optional
  optional PBQStorage storage = 3;
}

message HTTPSource {
  // +optional
  optional Authorization auth = 1;

  // Whether to create a ClusterIP Service
  // +optional
  optional bool service = 2;
}

// +genclient
// +kubebuilder:object:root=true
// +kubebuilder:resource:shortName=isbsvc
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Type",type=string,JSONPath=`.status.type`
// +kubebuilder:printcolumn:name="Phase",type=string,JSONPath=`.status.phase`
// +kubebuilder:printcolumn:name="Message",type=string,JSONPath=`.status.message`
// +kubebuilder:printcolumn:name="Age",type=date,JSONPath=`.metadata.creationTimestamp`
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +k8s:openapi-gen=true
message InterStepBufferService {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional InterStepBufferServiceSpec spec = 2;

  // +optional
  optional InterStepBufferServiceStatus status = 3;
}

// InterStepBufferServiceList is the list of InterStepBufferService resources
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message InterStepBufferServiceList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated InterStepBufferService items = 2;
}

message InterStepBufferServiceSpec {
  optional RedisBufferService redis = 1;

  optional JetStreamBufferService jetstream = 2;
}

message InterStepBufferServiceStatus {
  optional Status status = 1;

  optional string phase = 2;

  optional string message = 3;

  optional BufferServiceConfig config = 4;

  optional string type = 5;
}

message JetStreamBufferService {
  // JetStream version, such as "2.7.1"
  optional string version = 1;

  // Redis StatefulSet size
  // +kubebuilder:default=3
  optional int32 replicas = 2;

  // ContainerTemplate contains customized spec for NATS container
  // +optional
  optional ContainerTemplate containerTemplate = 3;

  // ReloaderContainerTemplate contains customized spec for config reloader container
  // +optional
  optional ContainerTemplate reloaderContainerTemplate = 4;

  // MetricsContainerTemplate contains customized spec for metrics container
  // +optional
  optional ContainerTemplate metricsContainerTemplate = 5;

  // +optional
  optional PersistenceStrategy persistence = 6;

  // +optional
  optional AbstractPodTemplate abstractPodTemplate = 7;

  // JetStream configuration, if not specified, global settings in numaflow-controller-config will be used.
  // See https://docs.nats.io/running-a-nats-service/configuration#jetstream.
  // Only configure "max_memory_store" or "max_file_store", do not set "store_dir" as it has been hardcoded.
  // +optional
  optional string settings = 8;

  // Optional arguments to start nats-server. For example, "-D" to enable debugging output, "-DV" to enable debugging and tracing.
  // Check https://docs.nats.io/ for all the available arguments.
  // +optional
  repeated string startArgs = 9;

  // Optional configuration for the streams, consumers and buckets to be created in this JetStream service, if specified, it will be merged with the default configuration in numaflow-controller-config.
  // It accepts a YAML format configuration, it may include 4 sections, "stream", "consumer", "otBucket" and "procBucket".
  // Available fields under "stream" include "retention" (e.g. interest, limits, workerQueue), "maxMsgs", "maxAge" (e.g. 72h), "replicas" (1, 3, 5), "duplicates" (e.g. 5m).
  // Available fields under "consumer" include "ackWait" (e.g. 60s)
  // Available fields under "otBucket" include "maxValueSize", "history", "ttl" (e.g. 72h), "maxBytes", "replicas" (1, 3, 5).
  // Available fields under "procBucket" include "maxValueSize", "history", "ttl" (e.g. 72h), "maxBytes", "replicas" (1, 3, 5).
  // +optional
  optional string bufferConfig = 10;

  // Whether encrypt the data at rest, defaults to false
  // Enabling encryption might impact the performance, see https://docs.nats.io/running-a-nats-service/nats_admin/jetstream_admin/encryption_at_rest for the detail
  // Toggling the value will impact encypting/decrypting existing messages.
  // +optional
  optional bool encryption = 11;

  // Whether enable TLS, defaults to false
  // Enabling TLS might impact the performance
  // +optional
  optional bool tls = 12;
}

message JetStreamConfig {
  // JetStream (NATS) URL
  optional string url = 1;

  optional NATSAuth auth = 2;

  // +optional
  optional string bufferConfig = 3;

  // TLS enabled or not
  optional bool tlsEnabled = 4;
}

message JobTemplate {
  // +optional
  optional AbstractPodTemplate abstractPodTemplate = 1;

  // +optional
  optional ContainerTemplate containerTemplate = 2;

  // ttlSecondsAfterFinished limits the lifetime of a Job that has finished
  // execution (either Complete or Failed). If this field is set,
  // ttlSecondsAfterFinished after the Job finishes, it is eligible to be
  // automatically deleted. When the Job is being deleted, its lifecycle
  // guarantees (e.g. finalizers) will be honored. If this field is unset,
  // the Job won't be automatically deleted. If this field is set to zero,
  // the Job becomes eligible to be deleted immediately after it finishes.
  // Numaflow defaults to 30
  // +optional
  optional int32 ttlSecondsAfterFinished = 3;

  // Specifies the number of retries before marking this job failed.
  // More info: https://kubernetes.io/docs/concepts/workloads/controllers/job/#pod-backoff-failure-policy
  // Numaflow defaults to 20
  // +optional
  optional int32 backoffLimit = 4;
}

message KafkaSink {
  repeated string brokers = 1;

  optional string topic = 2;

  // TLS user to configure TLS connection for kafka broker
  // TLS.enable=true default for TLS.
  // +optional
  optional TLS tls = 3;

  // +optional
  optional string config = 4;
}

message KafkaSource {
  repeated string brokers = 1;

  optional string topic = 2;

  optional string consumerGroup = 3;

  // TLS user to configure TLS connection for kafka broker
  // TLS.enable=true default for TLS.
  // +optional
  optional TLS tls = 4;

  // +optional
  optional string config = 5;
}

message Lifecycle {
  // DeleteGracePeriodSeconds used to delete pipeline gracefully
  // +kubebuilder:default=30
  // +optional
  optional int32 deleteGracePeriodSeconds = 1;

  // DesiredPhase used to bring the pipeline from current phase to desired phase
  // +kubebuilder:default=Running
  // +optional
  optional string desiredPhase = 2;
}

message Log {
}

message Metadata {
  map<string, string> annotations = 1;

  map<string, string> labels = 2;
}

message NATSAuth {
  // Secret for auth user
  // +optional
  optional k8s.io.api.core.v1.SecretKeySelector user = 1;

  // Secret for auth password
  // +optional
  optional k8s.io.api.core.v1.SecretKeySelector password = 2;
}

message NativeRedis {
  // Redis version, such as "6.0.16"
  optional string version = 1;

  // Redis StatefulSet size
  // +kubebuilder:default=3
  optional int32 replicas = 2;

  // RedisContainerTemplate contains customized spec for Redis container
  // +optional
  optional ContainerTemplate redisContainerTemplate = 3;

  // SentinelContainerTemplate contains customized spec for Redis container
  // +optional
  optional ContainerTemplate sentinelContainerTemplate = 4;

  // MetricsContainerTemplate contains customized spec for metrics container
  // +optional
  optional ContainerTemplate metricsContainerTemplate = 5;

  // +optional
  optional ContainerTemplate initContainerTemplate = 6;

  // +optional
  optional PersistenceStrategy persistence = 7;

  // +optional
  optional AbstractPodTemplate abstractPodTemplate = 8;

  // Redis configuration, if not specified, global settings in numaflow-controller-config will be used.
  // +optional
  optional RedisSettings settings = 9;
}

// PBQStorage defines the persistence configuration for a vertex.
message PBQStorage {
  optional PersistenceStrategy persistentVolumeClaim = 1;
}

// PersistenceStrategy defines the strategy of persistence
message PersistenceStrategy {
  // Name of the StorageClass required by the claim.
  // More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
  // +optional
  optional string storageClassName = 1;

  // Available access modes such as ReadWriteOnce, ReadWriteMany
  // https://kubernetes.io/docs/concepts/storage/persistent-volumes/#access-modes
  // +optional
  optional string accessMode = 2;

  // Volume size, e.g. 50Gi
  optional k8s.io.apimachinery.pkg.api.resource.Quantity volumeSize = 3;
}

// +genclient
// +kubebuilder:object:root=true
// +kubebuilder:resource:shortName=pl
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Phase",type=string,JSONPath=`.status.phase`
// +kubebuilder:printcolumn:name="Message",type=string,JSONPath=`.status.message`
// +kubebuilder:printcolumn:name="Vertices",type=integer,JSONPath=`.status.vertexCount`
// +kubebuilder:printcolumn:name="Sources",type=integer,JSONPath=`.status.sourceCount`,priority=10
// +kubebuilder:printcolumn:name="Sinks",type=integer,JSONPath=`.status.sinkCount`,priority=10
// +kubebuilder:printcolumn:name="UDFs",type=integer,JSONPath=`.status.udfCount`,priority=10
// +kubebuilder:printcolumn:name="Age",type=date,JSONPath=`.metadata.creationTimestamp`
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +k8s:openapi-gen=true
message Pipeline {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional PipelineSpec spec = 2;

  // +optional
  optional PipelineStatus status = 3;
}

message PipelineLimits {
  // Read batch size for all the vertices in the pipeline, can be overridden by the vertex's limit settings
  // +kubebuilder:default=500
  // +optional
  optional uint64 readBatchSize = 1;

  // BufferMaxLength is used to define the max length of a buffer
  // Only applies to UDF and Source vertice as only they do buffer write.
  // It can be overridden by the settings in vertex limits.
  // +kubebuilder:default=50000
  // +optional
  optional uint64 bufferMaxLength = 2;

  // BufferUsageLimit is used to define the percentage of the buffer usage limit, a valid value should be less than 100, for example, 85.
  // Only applies to UDF and Source vertice as only they do buffer write.
  // It will be overridden by the settings in vertex limits.
  // +kubebuilder:default=80
  // +optional
  optional uint32 bufferUsageLimit = 3;

  // Read timeout for all the vertices in the pipeline, can be overridden by the vertex's limit settings
  // +kubebuilder:default= "1s"
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Duration readTimeout = 4;
}

// +kubebuilder:object:root=true
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message PipelineList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated Pipeline items = 2;
}

message PipelineSpec {
  // +optional
  optional string interStepBufferServiceName = 1;

  // +patchStrategy=merge
  // +patchMergeKey=name
  repeated AbstractVertex vertices = 2;

  // Edges define the relationships between vertices
  repeated Edge edges = 3;

  // Lifecycle define the Lifecycle properties
  // +kubebuilder:default={"deleteGracePeriodSeconds": 30, "desiredPhase": Running}
  // +optional
  optional Lifecycle lifecycle = 4;

  // Limits define the limitations such as buffer read batch size for all the vertices of a pipeline, they could be overridden by each vertex's settings
  // +kubebuilder:default={"readBatchSize": 500, "bufferMaxLength": 30000, "bufferUsageLimit": 80}
  // +optional
  optional PipelineLimits limits = 5;

  // Watermark enables watermark progression across the entire pipeline. Updating this after the pipeline has been
  // created will have no impact and will be ignored. To make the pipeline honor any changes to the setting, the pipeline
  // should be recreated.
  // +kubebuilder:default={"disabled": false}
  // +optional
  optional Watermark watermark = 6;

  // Templates is used to customize additional kubernetes resources required for the Pipeline
  // +optional
  optional Templates templates = 7;
}

message PipelineStatus {
  optional Status status = 1;

  optional string phase = 2;

  optional string message = 3;

  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastUpdated = 4;

  optional uint32 vertexCount = 5;

  optional uint32 sourceCount = 6;

  optional uint32 sinkCount = 7;

  optional uint32 udfCount = 8;
}

message RedisBufferService {
  // Native brings up a native Redis service
  optional NativeRedis native = 1;

  // External holds an External Redis config
  optional RedisConfig external = 2;
}

message RedisConfig {
  // Redis URL
  // +optional
  optional string url = 1;

  // Sentinel URL, will be ignored if Redis URL is provided
  // +optional
  optional string sentinelUrl = 2;

  // Only required when Sentinel is used
  // +optional
  optional string masterName = 3;

  // Redis user
  // +optional
  optional string user = 4;

  // Redis password secret selector
  // +optional
  optional k8s.io.api.core.v1.SecretKeySelector password = 5;

  // Sentinel password secret selector
  // +optional
  optional k8s.io.api.core.v1.SecretKeySelector sentinelPassword = 6;
}

message RedisSettings {
  // Redis settings shared by both master and slaves, will override the global settings from controller config
  // +optional
  optional string redis = 1;

  // Special settings for Redis master node, will override the global settings from controller config
  // +optional
  optional string master = 2;

  // Special settings for Redis replica nodes, will override the global settings from controller config
  // +optional
  optional string replica = 3;

  // Sentinel settings, will override the global settings from controller config
  // +optional
  optional string sentinel = 4;
}

// Scale defines the parameters for autoscaling.
message Scale {
  // Whether to disable autoscaling.
  // Set to "true" when using Kubernetes HPA or any other 3rd party autoscaling strategies.
  // +optional
  optional bool disabled = 1;

  // Minimum replicas.
  // +optional
  optional int32 min = 2;

  // Maximum replicas.
  // +optional
  optional int32 max = 3;

  // Lookback seconds to calculate the average pending messages and processing rate.
  // +optional
  optional uint32 lookbackSeconds = 4;

  // Cooldown seconds after a scaling operation before another one.
  // +optional
  optional uint32 cooldownSeconds = 5;

  // After scaling down to 0, sleep how many seconds before scaling up to peek.
  // +optional
  optional uint32 zeroReplicaSleepSeconds = 6;

  // TargetProcessingSeconds is used to tune the aggressiveness of autoscaling for source vertices, it measures how fast
  // you want the vertex to process all the pending messages. Typically increasing the value, which leads to lower processing
  // rate, thus less replicas. It's only effective for source vertices.
  // +optional
  optional uint32 targetProcessingSeconds = 7;

  // TargetBufferUsage is used to define the target percentage of usage of the buffer to be read.
  // A valid and meaningful value should be less than the BufferUsageLimit defined in the Edge spec (or Pipeline spec), for example, 50.
  // It only applies to UDF and Sink vertices as only they have buffers to read.
  // +optional
  optional uint32 targetBufferUsage = 8;

  // ReplicasPerScale defines maximum replicas can be scaled up or down at once.
  // The is use to prevent too aggressive scaling operations
  // +optional
  optional uint32 replicasPerScale = 9;
}

message Sink {
  optional Log log = 1;

  optional KafkaSink kafka = 2;

  optional UDSink udsink = 3;
}

message Source {
  // +optional
  optional GeneratorSource generator = 1;

  // +optional
  optional KafkaSource kafka = 2;

  // +optional
  optional HTTPSource http = 3;
}

// Status is a common structure which can be used for Status field.
message Status {
  // Conditions are the latest available observations of a resource's current state.
  // +optional
  // +patchMergeKey=type
  // +patchStrategy=merge
  repeated k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 1;
}

message TLS {
  // +optional
  optional bool insecureSkipVerify = 1;

  // CACertSecret refers to the secret that contains the CA cert
  // +optional
  optional k8s.io.api.core.v1.SecretKeySelector caCertSecret = 2;

  // CertSecret refers to the secret that contains the cert
  // +optional
  optional k8s.io.api.core.v1.SecretKeySelector certSecret = 3;

  // KeySecret refers to the secret that contains the key
  // +optional
  optional k8s.io.api.core.v1.SecretKeySelector keySecret = 4;
}

message Templates {
  // DaemonTemplate is used to customize the Daemon Deployment
  // +optional
  optional DaemonTemplate daemon = 1;

  // JobTemplate is used to customize Jobs
  // +optional
  optional JobTemplate job = 2;

  // VertexTemplate is used to customize Vertices
  // +optional
  optional VertexTemplate vertex = 3;
}

message UDF {
  // +optional
  optional Container container = 1;

  // +optional
  optional Function builtin = 2;

  // +optional
  optional GroupBy groupBy = 3;
}

message UDSink {
  optional Container container = 1;
}

// +genclient
// +kubebuilder:object:root=true
// +kubebuilder:resource:shortName=vtx
// +kubebuilder:subresource:status
// +kubebuilder:subresource:scale:specpath=.spec.replicas,statuspath=.status.replicas,selectorpath=.status.selector
// +kubebuilder:printcolumn:name="Phase",type=string,JSONPath=`.status.phase`
// +kubebuilder:printcolumn:name="Reason",type=string,JSONPath=`.status.reason`
// +kubebuilder:printcolumn:name="Message",type=string,JSONPath=`.status.message`
// +kubebuilder:printcolumn:name="Desired",type=string,JSONPath=`.spec.replicas`
// +kubebuilder:printcolumn:name="Current",type=string,JSONPath=`.status.replicas`
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +k8s:openapi-gen=true
message Vertex {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional VertexSpec spec = 2;

  // +optional
  optional VertexStatus status = 3;
}

// VertexInstance is a wrapper of a vertex instance, which contains the vertex spec and the instance information such as hostname and replica index.
message VertexInstance {
  optional Vertex vertex = 1;

  optional string hostname = 2;

  optional int32 replica = 3;
}

message VertexLimits {
  // Read batch size from the source or buffer.
  // It overrides the settings from pipeline limits.
  // +optional
  optional uint64 readBatchSize = 1;

  // Read timeout duration from the source or buffer
  // It overrides the settings from pipeline limits.
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Duration readTimeout = 2;
}

// +kubebuilder:object:root=true
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message VertexList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated Vertex items = 2;
}

message VertexSpec {
  optional AbstractVertex abstractVertex = 1;

  optional string pipelineName = 2;

  // +optional
  optional string interStepBufferServiceName = 3;

  // +kubebuilder:default=1
  // +optional
  optional int32 replicas = 4;

  // +optional
  repeated Edge fromEdges = 5;

  // +optional
  repeated Edge toEdges = 6;
}

message VertexStatus {
  optional string phase = 1;

  optional string reason = 6;

  optional string message = 2;

  optional uint32 replicas = 3;

  optional string selector = 5;

  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastScaledAt = 4;
}

message VertexTemplate {
  // +optional
  optional AbstractPodTemplate abstractPodTemplate = 1;

  // +optional
  optional ContainerTemplate containerTemplate = 2;

  // +optional
  optional ContainerTemplate initContainerTemplate = 3;
}

message Watermark {
  // Disabled toggles the watermark propagation, defaults to false.
  // +kubebuilder:default=false
  // +optional
  optional bool disabled = 1;

  // Maximum delay allowed for watermark calculation, defaults to "0s", which means no delay.
  // +kubebuilder:default="0s"
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Duration maxDelay = 2;
}

// Window describes windowing strategy
message Window {
  // +optional
  optional FixedWindow fixed = 1;
}

