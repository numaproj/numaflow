package main


// orchestrator 

orchestrator.init() {
	controlloop.init()
}

orchestrator.start() {
	controlloop.run()
	// shutdown hooks etc. 
}

controlloop.init() {
	// control server (grpc) initialization
}

controlloop.run() {
	for {
		// listen on a certain port for signals
		signal := controlserver.receive()
		switch signal.type {
		case "newstream": 
			reader := reader.New(signal.streamId)
			writer := writer.New(signal.streamId)
			udf := udffunc.New()
			// optional setup in udf to setup things
			udf.setup()
			for i in range 1..parallelism:
				async udf.run()

		case "terminate":
			for udf in udfs {
				// optional method in udf to clean up 
				udf.finalize()
			}
		}
	}
}

controlloop.stop() {
	// control server termination and clean up
}


// main container
init() {
	dataloop.init()
	writer.init()
	writer.start()
	reader.init()
	reader.start()
}

dataloop.init() {
	queuehandle := persistentqueue.init(capacity int)
	streammap.put(streamid, queuehandle)
	dataserver.init()
	dataserver.start()
}

dataserver.read(streamid, n int) {
	streammap.get(streamId).readN(n)
	// read N and its variations can be supported.
}

dataserver.write(records []Record) {
	writer.write(records)
	watermark.update()
}

reader.init() {
	// ISB reader setup
	reader := NewReader(from isb, to queuehandle)
}

reader.start() {
	for {
		records []Record := reader.read()
		persistentqueue.persist(records)
		ack(records)
	}
}

// writer variants similar to readers



// udf author


// import mappingfunc from numaflowfuncs
def my_udf(reader, writer):
   pass

def another_func(reader, writer):
    pass


// filter udf
def my_handler(input, accumulator, windowcfg):
    for msg in input:
		if random.randint(0, 10) % 2 == 0:
			accumulator.add(msg)

// reducer udf
def my_handler(input, accumulator, windowcfg):
	reducedval = 0
    for msg in input:
		reducedval = msg.numericattr + reducedval
	
	accumulator.add(reducedval)

// mapper udf
def my_handler(input, accumulator, windowcfg):
    for msg in input:
		accumulator.add(my_mapper(msg))


class Reader:

	def __init__(self, grpclient, options):
		self.grpclient = grpcclient
		self.options = options

	def __iter__(self):
		return self

	def __next__(self):
		// could initialize a buffer here to make reads efficinet
		// but we need a buffer backed by the grpc client
		async fill_buffer(self.grpcclient)
		if not EOF:
			return buffer.next()
		else:
			raise StopIteration

# initialize the reader
reader = Reader(grpclient, options = { key=mykey, windowid=uuidforwindow, window_starttime=ts})

# create an iterable from the object
iterable = iter(reader)

// pass the iterable to the udf invocation
my_handler(iterable, accumulator, self.key, self.options)
