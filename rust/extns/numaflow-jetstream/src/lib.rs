use std::sync::Arc;
use std::{collections::HashMap, time::Duration};

use async_nats::jetstream::consumer::{AckPolicy, DeliverPolicy};
use async_nats::jetstream::{AckKind, Message as JetstreamMessage, consumer};
use async_nats::{
    ConnectOptions,
    jetstream::consumer::{
        Consumer, PullConsumer,
        pull::{Config, Stream},
    },
};
use backoff::retry::Retry;
use backoff::strategy::fixed;
use bytes::Bytes;
use chrono::DateTime;
use rustls_pki_types::pem::PemObject;
use rustls_pki_types::{CertificateDer, PrivateKeyDer};
use tls::NoVerifier;
use tokio::sync::{mpsc, oneshot};
use tokio::task::JoinHandle;
use tokio::time::{self, Instant};
use tokio_stream::StreamExt;

pub type Result<T> = core::result::Result<T, Error>;

mod tls;

#[derive(thiserror::Error, Debug)]
pub enum Error {
    #[error("Connecting to NATS {server} - {error}")]
    Connection { server: String, error: String },

    #[error("Jestream - {0}")]
    Jetstream(String),

    #[error("{0}")]
    Other(String),
}

/// Represents the authentication method used to connect to NATS.
/// https://numaflow.numaproj.io/user-guide/sources/nats/#auth
#[derive(Debug, Clone, PartialEq)]
pub enum NatsAuth {
    Basic { username: String, password: String },
    NKey(String),
    Token(String),
}

#[derive(Debug, Clone, PartialEq)]
pub struct TlsConfig {
    pub insecure_skip_verify: bool,
    pub ca_cert: Option<String>,
    pub client_auth: Option<TlsClientAuthCerts>,
}

#[derive(Debug, Clone, PartialEq)]
pub struct TlsClientAuthCerts {
    pub client_cert: String,
    pub client_cert_private_key: String,
}

#[derive(Debug, Clone, PartialEq)]
pub enum JetstreamConsumerName {
    UserSpecified(String),
    Default(String),
}

impl AsRef<str> for JetstreamConsumerName {
    fn as_ref(&self) -> &str {
        match self {
            JetstreamConsumerName::UserSpecified(name) => name,
            JetstreamConsumerName::Default(name) => name,
        }
    }
}

#[derive(Debug, Clone, PartialEq)]
pub struct JetstreamSourceConfig {
    pub addr: String,
    pub stream: String,
    pub consumer: JetstreamConsumerName,
    pub auth: Option<NatsAuth>,
    pub tls: Option<TlsConfig>,
}

/// Message represents a message received from Jetstream which can be converted to Numaflow Message.
#[derive(Debug)]
pub struct Message {
    /// The user payload.
    pub value: Bytes,
    /// Monotonically increasing sequence number as generated by JetStream.
    pub stream_sequence: u64,
    pub published_timestamp: DateTime<chrono::Utc>,
    pub headers: HashMap<String, String>,
}

impl TryFrom<JetstreamMessage> for Message {
    type Error = Error;
    fn try_from(msg: JetstreamMessage) -> Result<Self> {
        let headers = match msg.message.headers.as_ref() {
            Some(headers) => headers
                .iter()
                .map(|(k, v)| (k.to_string(), v[0].as_str().to_string())) //NOTE: we are only using the first value of the header
                .collect(),
            None => HashMap::new(),
        };

        let stream_sequence = msg
            .info()
            .map_err(|e| {
                Error::Jetstream(format!("fetching message metadata from Jetstream: {e:?}"))
            })?
            .stream_sequence;

        let published_timestamp = msg
            .info()
            .map_err(|e| {
                Error::Jetstream(format!("fetching message metadata from Jetstream: {e:?}"))
            })?
            .published;

        Ok(Message {
            value: msg.message.payload,
            stream_sequence,
            headers,
            published_timestamp: DateTime::from_timestamp(
                published_timestamp.unix_timestamp(),
                published_timestamp.nanosecond(),
            )
            .expect("Failed to convert timestamp to DateTime"),
        })
    }
}

enum JetstreamActorMessage {
    Read {
        respond_to: oneshot::Sender<Result<Vec<Message>>>,
    },
    Ack {
        offsets: Vec<u64>,
        respond_to: oneshot::Sender<Result<()>>,
    },
    Pending {
        respond_to: oneshot::Sender<Result<Option<usize>>>,
    },
}

struct JetstreamActor {
    consumer: Consumer<Config>,
    messages: Stream,
    read_timeout: Duration,
    batch_size: usize,
    in_progress_messages: HashMap<u64, MessageProcessingTracker>,
    handler_rx: mpsc::Receiver<JetstreamActorMessage>,
}

impl JetstreamActor {
    async fn start(
        config: JetstreamSourceConfig,
        batch_size: usize,
        read_timeout: Duration,
        handler_rx: mpsc::Receiver<JetstreamActorMessage>,
    ) -> Result<()> {
        let mut conn_opts = ConnectOptions::new()
            .max_reconnects(None) // unlimited reconnects
            .reconnect_delay_callback(|attempts| {
                std::time::Duration::from_millis(std::cmp::min((attempts * 10) as u64, 1000))
            })
            .ping_interval(Duration::from_secs(3))
            .retry_on_initial_connect();
        if let Some(auth) = config.auth {
            conn_opts = match auth {
                NatsAuth::Basic { username, password } => {
                    conn_opts.user_and_password(username, password)
                }
                NatsAuth::NKey(nkey) => conn_opts.nkey(nkey),
                NatsAuth::Token(token) => conn_opts.token(token),
            };
        }
        if let Some(tls_config) = config.tls {
            conn_opts = Self::configure_tls(conn_opts, tls_config)?;
        }
        let client = async_nats::connect_with_options(&config.addr, conn_opts)
            .await
            .map_err(|err| Error::Connection {
                server: config.addr.to_string(),
                error: err.to_string(),
            })?;

        let js_ctx = async_nats::jetstream::new(client);
        let consumer: PullConsumer = match config.consumer {
            JetstreamConsumerName::UserSpecified(name) => js_ctx
                .get_consumer_from_stream(&name, &config.stream)
                .await
                .map_err(|e| {
                    Error::Jetstream(format!(
                        "Getting consumer {} from Jetstream stream {}: {e:?}",
                        name, config.stream
                    ))
                })?,
            JetstreamConsumerName::Default(name) => js_ctx
                .create_consumer_on_stream(
                    consumer::pull::Config {
                        durable_name: Some(name.clone()),
                        description: Some("Numaflow Jetstream Consumer".into()),
                        deliver_policy: DeliverPolicy::All,
                        ack_policy: AckPolicy::Explicit,
                        ..Default::default()
                    },
                    &config.stream,
                )
                .await
                .map_err(|e| {
                    Error::Jetstream(format!(
                        "Creating consumer {} on stream {}: {e:?}",
                        name, config.stream
                    ))
                })?,
        };

        let message_stream = consumer.messages().await.unwrap();

        tokio::spawn(async move {
            let mut actor = JetstreamActor {
                consumer,
                messages: message_stream,
                read_timeout,
                batch_size,
                in_progress_messages: HashMap::new(),
                handler_rx,
            };
            tracing::info!("Starting Jetstream...");
            actor.run().await;
        });

        Ok(())
    }

    fn configure_tls(
        mut conn_opts: ConnectOptions,
        tls_config: TlsConfig,
    ) -> Result<ConnectOptions> {
        if tls_config.insecure_skip_verify {
            tracing::warn!(
                "'insecureSkipVerify' is set to true, certificate validation will not be performed when connecting to NATS server"
            );
            let tls_client_config = rustls::ClientConfig::builder()
                .dangerous()
                .with_custom_certificate_verifier(Arc::new(NoVerifier))
                .with_no_client_auth();
            conn_opts = conn_opts
                .require_tls(true)
                .tls_client_config(tls_client_config);
        } else {
            let root_store = Self::load_root_store(tls_config.ca_cert)?;
            let tls_client = Self::configure_client_auth(tls_config.client_auth, root_store)?;
            conn_opts = conn_opts.require_tls(true).tls_client_config(tls_client);
        }
        Ok(conn_opts)
    }

    fn load_root_store(ca_cert: Option<String>) -> Result<rustls::RootCertStore> {
        let mut root_store = rustls::RootCertStore::empty();
        let native_certs = rustls_native_certs::load_native_certs();
        if !native_certs.errors.is_empty() {
            return Err(Error::Other(format!(
                "Loading native certs from certificate store: {:?}",
                native_certs.errors
            )));
        }
        root_store.add_parsable_certificates(native_certs.unwrap());
        if let Some(ca_cert) = ca_cert {
            let cert = CertificateDer::from_pem_slice(ca_cert.as_bytes())
                .map_err(|err| Error::Other(format!("Parsing CA cert: {err:?}")))?;
            root_store.add(cert).map_err(|err| {
                Error::Other(format!("Adding CA cert to in-memory cert store: {err:?}"))
            })?;
        }
        Ok(root_store)
    }

    fn configure_client_auth(
        client_auth: Option<TlsClientAuthCerts>,
        root_store: rustls::RootCertStore,
    ) -> Result<rustls::ClientConfig> {
        match client_auth {
            Some(client_auth) => {
                let client_cert = CertificateDer::from_pem_slice(
                    client_auth.client_cert.as_bytes(),
                )
                .map_err(|err| Error::Other(format!("Parsing client tls certificate: {err:?}")))?;
                let client_key =
                    PrivateKeyDer::from_pem_slice(client_auth.client_cert_private_key.as_bytes())
                        .map_err(|err| {
                        Error::Other(format!("Parsing client tls private key: {err:?}"))
                    })?;
                rustls::ClientConfig::builder()
                    .with_root_certificates(root_store)
                    .with_client_auth_cert(vec![client_cert], client_key)
                    .map_err(|err| {
                        Error::Other(format!("Client TLS private key is invalid: {err:?}"))
                    })
            }
            None => Ok(rustls::ClientConfig::builder()
                .with_root_certificates(root_store)
                .with_no_client_auth()),
        }
    }

    async fn run(&mut self) {
        while let Some(msg) = self.handler_rx.recv().await {
            self.handle_message(msg).await;
        }
    }

    async fn handle_message(&mut self, msg: JetstreamActorMessage) {
        match msg {
            JetstreamActorMessage::Read { respond_to } => {
                let messages = self.read_messages().await;
                let _ = respond_to.send(messages);
            }
            JetstreamActorMessage::Ack {
                offsets,
                respond_to,
            } => {
                let status = self.ack_messages(offsets).await;
                let _ = respond_to.send(status);
            }
            JetstreamActorMessage::Pending { respond_to } => {
                let pending = self.pending_messages().await;
                let _ = respond_to.send(pending);
            }
        }
    }

    /// Reads messages from the Jetstream stream with honoring timeouts.
    async fn read_messages(&mut self) -> Result<Vec<Message>> {
        let mut messages: Vec<Message> = vec![];
        let timeout = tokio::time::timeout(self.read_timeout, std::future::pending::<()>());
        tokio::pin!(timeout);
        loop {
            if messages.len() >= self.batch_size {
                break;
            }
            tokio::select! {
                biased;

                _ = &mut timeout => {
                    break;
                }

                message = self.messages.next() => {
                    let Some(message) = message else {
                        break;
                    };
                    let message = message
                        .map_err(|e| Error::Jetstream(format!("Getting next message from the stream: {e:?}")))?;
                    let message = self.process_message(message).await?;
                    messages.push(message);
                }
            }
        }
        tracing::debug!(msg_count = messages.len(), "Read messages from Jetstream");
        Ok(messages)
    }

    async fn ack_messages(&mut self, offsets: Vec<u64>) -> Result<()> {
        let mut tasks = Vec::with_capacity(offsets.len());

        for offset in offsets {
            let msg_task = self.in_progress_messages.remove(&offset);
            let Some(msg_task) = msg_task else {
                tracing::warn!(offset, "Received ACK request for unknown offset");
                continue;
            };

            // msg_task.ack() involves sending on a oneshot channel to an already running tokio task
            // This results in sending Ack to Nats server (within the tokio task) and awaiting for
            // the task to finish. We spawn tasks here so that acks happens concurrently.
            let task = tokio::spawn(async move {
                msg_task.ack().await;
            });
            tasks.push(task);
        }

        for task in tasks {
            if let Err(err) = task.await {
                return Err(Error::Other(format!("Error in ack task: {err:?}")));
            }
        }
        Ok(())
    }

    async fn process_message(&mut self, js_message: JetstreamMessage) -> Result<Message> {
        // we need to clone because the message should be held around for ack
        let message: Message = js_message.clone().try_into().map_err(|e| {
            Error::Jetstream(format!(
                "converting raw Jetstream message as Numaflow source message: {e:?}"
            ))
        })?;

        // we need to start WIP ack because some processing can be quite slow and we have to avoid
        // redelivery.
        let tick_interval = self.consumer.cached_info().config.ack_wait / 2;
        let message_tracker = MessageProcessingTracker::start(js_message, tick_interval).await;
        self.in_progress_messages
            .insert(message.stream_sequence, message_tracker);

        Ok(message)
    }

    pub async fn pending_messages(&mut self) -> Result<Option<usize>> {
        let x = self
            .consumer
            .info()
            .await
            .map_err(|e| Error::Jetstream(format!("Failed to get consumer info: {e:?}")))?;

        Ok(Some(x.num_pending as usize + x.num_ack_pending))
    }
}

#[derive(Clone)]
pub struct JetstreamSource {
    actor_tx: mpsc::Sender<JetstreamActorMessage>,
}

impl JetstreamSource {
    pub async fn connect(
        config: JetstreamSourceConfig,
        batch_size: usize,
        read_timeout: Duration,
    ) -> Result<Self> {
        let (tx, rx) = mpsc::channel(10);
        JetstreamActor::start(config, batch_size, read_timeout, rx).await?;
        Ok(Self { actor_tx: tx })
    }

    pub async fn read_messages(&self) -> Result<Vec<Message>> {
        let (tx, rx) = oneshot::channel();
        let msg = JetstreamActorMessage::Read { respond_to: tx };
        let _ = self.actor_tx.send(msg).await;
        rx.await
            .map_err(|_| Error::Other("Actor task terminated".into()))?
    }

    pub async fn ack_messages(&self, offsets: Vec<u64>) -> Result<()> {
        let (tx, rx) = oneshot::channel();
        let msg = JetstreamActorMessage::Ack {
            offsets,
            respond_to: tx,
        };
        let _ = self.actor_tx.send(msg).await;
        rx.await
            .map_err(|_| Error::Other("Actor task terminated".into()))?
    }

    pub async fn pending_messages(&self) -> Result<Option<usize>> {
        let (tx, rx) = oneshot::channel();
        let msg = JetstreamActorMessage::Pending { respond_to: tx };
        let _ = self.actor_tx.send(msg).await;
        rx.await
            .map_err(|_| Error::Other("Actor task terminated".into()))?
    }
}

/// The MessageProcessingTracker object is a handle to the work-in-progress background task for a
/// message. The background task periodically sends `AckKind::Progress` to the Nats server while the
/// message is being processed. This handle will be tracked as value in a hashmap in the Jetstream
/// source handle where the key will be the corresponding message sequence id (offset).
/// When the `Sourcer` trait's ack is called, the `MessageProcessingTracker::ack` gets called, which
/// results in marking the message processing completion in Nats server and termination of the
/// work-in-progress task.
struct MessageProcessingTracker {
    in_progress_task: JoinHandle<()>,
    ack_signal_tx: oneshot::Sender<()>,
}

// same as rust/numaflow-core/src/pipeline/isb/jestream/reader.rs
const ACK_RETRY_INTERVAL: u64 = 100;
const ACK_RETRY_ATTEMPTS: usize = usize::MAX;

impl MessageProcessingTracker {
    async fn start(msg: JetstreamMessage, tick: Duration) -> Self {
        let (ack_signal_tx, ack_signal_rx) = oneshot::channel();
        let task = tokio::spawn(Self::start_work_in_progress(msg, tick, ack_signal_rx));
        Self {
            in_progress_task: task,
            ack_signal_tx,
        }
    }

    /// Starts a background task to send an ACK to Jetstream for the message. It will do the final
    /// ACK/NACK after the task is completed.
    async fn start_work_in_progress(
        msg: JetstreamMessage,
        tick: Duration,
        ack_signal_rx: oneshot::Receiver<()>,
    ) {
        let start = Instant::now();
        let mut interval = time::interval_at(start + tick, tick);

        let ack_retry_interval =
            fixed::Interval::from_millis(ACK_RETRY_INTERVAL).take(ACK_RETRY_ATTEMPTS);
        let nack_retry_interval =
            fixed::Interval::from_millis(ACK_RETRY_INTERVAL).take(ACK_RETRY_ATTEMPTS);

        let ack_msg = async || {
            if let Err(err) = msg.ack().await {
                tracing::error!(?err, "Failed to Ack message");
                return Err(format!("Acknowledging Jetstream message: {err:?}"));
            }
            Ok(())
        };

        let ack_with_retry = Retry::new(ack_retry_interval, ack_msg, |_: &String| true);

        let ack_in_progress = async || {
            let ack_result = msg.ack_with(AckKind::Progress).await;
            if let Err(e) = ack_result {
                tracing::error!(?e, "Failed to send InProgress Ack to Jetstream for message");
            }
        };

        let nack_msg = async || {
            let ack_result = msg.ack_with(AckKind::Nak(None)).await;
            if let Err(e) = ack_result {
                tracing::error!(?e, "Failed to send InProgress Ack to Jetstream for message");
                return Err(format!(
                    "Sending Negative Ack to Jetstream for the message: {e:?}"
                ));
            }
            Ok(())
        };

        let nack_with_retry = Retry::new(nack_retry_interval, nack_msg, |_: &String| true);

        tokio::pin!(ack_signal_rx);

        loop {
            let ack = tokio::select! {
                biased;

                ack = &mut ack_signal_rx => ack,
                _ = interval.tick() => {
                    ack_in_progress().await;
                    continue;
                },
            };

            if let Err(e) = ack {
                tracing::error!(error=?e, "Received error while waiting for Ack on oneshot channel");
                if let Err(e) = nack_with_retry.await {
                    tracing::error!(error=?e, "Failed to send Negative Ack for the jetstream message even after retries");
                }
            }
            break;
        }
        if let Err(e) = ack_with_retry.await {
            tracing::error!(error=?e, "Failed to ACK jetstream message even after retries");
        }
    }

    async fn ack(self) {
        let Self {
            in_progress_task,
            ack_signal_tx,
        } = self;
        if let Err(err) = ack_signal_tx.send(()) {
            tracing::error!(
                ?err,
                "Background task to mark the message status as in-progress is already terminated"
            );
            return;
        }
        let _ = in_progress_task.await;
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use async_nats::ConnectOptions;

    #[tokio::test]
    async fn test_configure_tls_insecure_skip_verify() {
        let _ = rustls::crypto::aws_lc_rs::default_provider().install_default();
        let tls_config = TlsConfig {
            insecure_skip_verify: true,
            ca_cert: None,
            client_auth: None,
        };

        let conn_opts = ConnectOptions::new();
        let result = JetstreamActor::configure_tls(conn_opts, tls_config);

        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_configure_tls_invalid_ca_cert() {
        let _ = rustls::crypto::aws_lc_rs::default_provider().install_default();
        let tls_config = TlsConfig {
            insecure_skip_verify: false,
            ca_cert: Some("-----BEGIN CERTIFICATE-----\n...".to_string()),
            client_auth: None,
        };

        let conn_opts = ConnectOptions::new();
        let result = JetstreamActor::configure_tls(conn_opts, tls_config);

        assert!(result.is_err());
        let err = result.unwrap_err();
        let Error::Other(cert_err) = err else {
            panic!("unexpected error variant");
        };
        assert!(cert_err.starts_with("Parsing CA cert"));
    }

    #[tokio::test]
    async fn test_configure_tls_with_client_auth() {
        let _ = rustls::crypto::aws_lc_rs::default_provider().install_default();
        let tls_config = TlsConfig {
            insecure_skip_verify: false,
            ca_cert: Some(
                r#"-----BEGIN CERTIFICATE-----
MIIEmTCCAwGgAwIBAgIQOnQDenOU6LzG5RbfGNGlkjANBgkqhkiG9w0BAQsFADBl
MR4wHAYDVQQKExVta2NlcnQgZGV2ZWxvcG1lbnQgQ0ExHTAbBgNVBAsMFHJvb3RA
YnVpbGRraXRzYW5kYm94MSQwIgYDVQQDDBtta2NlcnQgcm9vdEBidWlsZGtpdHNh
bmRib3gwHhcNMjUwMzI1MDkyMTM1WhcNMzUwMzI1MDkyMTM1WjBlMR4wHAYDVQQK
ExVta2NlcnQgZGV2ZWxvcG1lbnQgQ0ExHTAbBgNVBAsMFHJvb3RAYnVpbGRraXRz
YW5kYm94MSQwIgYDVQQDDBtta2NlcnQgcm9vdEBidWlsZGtpdHNhbmRib3gwggGi
MA0GCSqGSIb3DQEBAQUAA4IBjwAwggGKAoIBgQDPWLCmd0BW0Ht7xin/DdGig6ak
Q00IaWnFOL5ZkjOFGq19nObepztwUELtTu04Up0OdS9gJMGnlZWnDAfMxL7BeyGP
WQ6kkph9c58xAWzcNT3LJPbLvhozuvCF8epaK8fJjyUH2ZOkuUyxbWxGHotrcuqg
12l/kv45gCYkiRcpw1np05JNr0LfHTtB2bC6L+rT9XkhcCTgT6Jn6mAV7DrTAFE4
itrB+7A3unsaetBFH8psHWxfUb0wEBCw1D0jiAwd6gyvKWgzdvRyyLofSAXECTt2
8PcA+3LnAgIm9KlpIxDUcM19hW8k4dm2uSINnZtOQUPO+p9lb8dobnIkGfzaLMb8
fKas+A24B17IyN7Pd1oEbx8CdLA1/hFeoR/rOMuZZG+DPP2au19+J2irz9YYaQSU
d0PMlMhdex5HFSKx0VwXbm0Q5LL4l6D+RYAEFxNeq0NL/GdxEg6wn01rh3sQdPns
WmLeY2KJKD/GABZhGoDsfNt2V6bXDG8gE3RyYvMCAwEAAaNFMEMwDgYDVR0PAQH/
BAQDAgIEMBIGA1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFDrbgKJvJRAgdVwc
hLoJAJbpJbxWMA0GCSqGSIb3DQEBCwUAA4IBgQAbkgEOuQPxmm7UsU84PXihHYPQ
pLBTSO0NIlESwJxpSAg04UxjTwQepPWvriYHTYunc3LKknjbplm6SZpV+s0ofhxV
vP0eO6NH/Ip5bdWWC1IrILbsL6l2ceNutQDWlvXUMmKETuTbT4TmXS/TB9O4ZtVr
1awcc6jvB0Ds+cnd7AZZPMQfPXQXUN6roPF1rIamXU3qrN2kAanGDzNmR740Lnfb
WeTIHnjMq4Pllo14TbDK0YNpCtuoneBERp40JOlOKPa+sWH2AFG0STiXuoY0m9TN
XguD4005MJq0gi3uy2HUdO1L0v8bYzqwvbrlCdyTrcsE7gUjiWUsicAYISfVOj7H
9h89s7CHH3I3CWFNvAFWV7Frug9iqKyxYr7+0eGpx2NR+4cdS4co3C+G6NjlE2ET
aVpDuM0QKJTM/Xs+h0htNcosO1ti7fNAjv4z5DZO635hP4Y3QqsD8aELcihP0CBq
5mXTljzZ334dfFcyLlbWZrLPHpcCWbWGQYdIdF4=
-----END CERTIFICATE-----"#
                    .into(),
            ),
            client_auth: Some(TlsClientAuthCerts {
                client_cert: "-----BEGIN CERTIFICATE-----
MIIETjCCAragAwIBAgIRAKmqnT/hu7Ewsl5V4Le6RdUwDQYJKoZIhvcNAQELBQAw
ZTEeMBwGA1UEChMVbWtjZXJ0IGRldmVsb3BtZW50IENBMR0wGwYDVQQLDBRyb290
QGJ1aWxka2l0c2FuZGJveDEkMCIGA1UEAwwbbWtjZXJ0IHJvb3RAYnVpbGRraXRz
YW5kYm94MB4XDTI1MDMyNTExMzMxMFoXDTI3MDYyNTExMzMxMFowSDEnMCUGA1UE
ChMebWtjZXJ0IGRldmVsb3BtZW50IGNlcnRpZmljYXRlMR0wGwYDVQQLDBRyb290
QGJ1aWxka2l0c2FuZGJveDCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEB
AJuqarht8aU3oY0rUKLPxsAXgRUkby2I9nxpLiVvMX3z8uOR7k8peiJ0NgOWXsRb
fD681AB/W/6aUcnV1FHMkF2SlAUNr+iyyQ7JUr26/r0cgFcfLO+fRY++qZzLrAMG
LLSzoI3/m7dbI7WZYBwBoXwv0QyZk4H1TL1E8IkCJ5yLEprFZEBh2UX437KNu3gj
ipwrk+IC3ehT9G9r0udpU3TTlk0uS9GcHVOkC4khNMkXCAGjRcdZOWfDJXKYfR2a
QE4a+OYeEvOZJgdzxKK4D5AFLa5z1bbOfpKzFixGnsrNBVVEOURajVv6rRhfe938
98i1w3KWSHlIruhXeHAUWOUCAwEAAaOBlTCBkjAOBgNVHQ8BAf8EBAMCBaAwJwYD
VR0lBCAwHgYIKwYBBQUHAwIGCCsGAQUFBwMBBggrBgEFBQcDBDAfBgNVHSMEGDAW
gBQ624CibyUQIHVcHIS6CQCW6SW8VjA2BgNVHREELzAtgglsb2NhbGhvc3SCD25h
dHMtc2VydmVyLXRsc4EPZW1haWxAbG9jYWxob3N0MA0GCSqGSIb3DQEBCwUAA4IB
gQCtzNu/i5q2zHpnrCXSL+1Dd8Sc7l0hGA0bUX2sgAJoo2mOywOAH2xNHac5Y2Wm
1ZXxlim0DfYgnPEbPO14CiRHN3Ho2lJqkDWvPjUnudLO4R9fqtKqMLWjqggYLhvY
35h3Eou8xxXTzlNgm8y/4DzPwZt+Ta+4AmT2niYHhYl6aQTCfBkBTuy4+OdE9cgc
w1Zd4hiRUXiydoZnaNdis/7v6yL+sWB8mP0HYY4qpq0FSQxSDsXaVnfW9Ly4vUu0
/KryRQbnGbCKDSP8YycEgRPrmZoQmbwGY21L3RWw+6cM+t9cjWaw5bnlo6rH2nqM
pD7OKMmhWWFyHIOJlP55bT23I8+KzMpfEb8TkXeSLPj1Kp//vapuWO5++dat5vLc
7uA4lagnnbG9Z0T0YOvMUv2n/+RV9UpfyzATUVCWih8zCrpW3EJDRHsHq3blgUdB
dl84hz7cZ26/EMHN4OaQmFvr5Haqm8SNn9YiUPDQWKfcqAQtts/+F0TFbndwX/H/
qaw=
-----END CERTIFICATE-----"
                    .to_string(),
                client_cert_private_key: "-----BEGIN PRIVATE KEY-----
MIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQCbqmq4bfGlN6GN
K1Ciz8bAF4EVJG8tiPZ8aS4lbzF98/Ljke5PKXoidDYDll7EW3w+vNQAf1v+mlHJ
1dRRzJBdkpQFDa/osskOyVK9uv69HIBXHyzvn0WPvqmcy6wDBiy0s6CN/5u3WyO1
mWAcAaF8L9EMmZOB9Uy9RPCJAiecixKaxWRAYdlF+N+yjbt4I4qcK5PiAt3oU/Rv
a9LnaVN005ZNLkvRnB1TpAuJITTJFwgBo0XHWTlnwyVymH0dmkBOGvjmHhLzmSYH
c8SiuA+QBS2uc9W2zn6SsxYsRp7KzQVVRDlEWo1b+q0YX3vd/PfItcNylkh5SK7o
V3hwFFjlAgMBAAECggEBAITmKdbrhrMXm8V6hY169qRpbLswL/sgQ9BTvCIZnJd7
/pJrtJnBP5TKwpKtfpsFwD2P2S/TjCcCeXFoLazoiRhaXCU0WkrA2QbWut1hGLs7
6hZ3d1XdFPZ0QTqsaF7slp5v/VM+NyODnCkemP9QJR5xdHjdZSI+2xV8Fh/ixw7O
GGJ9IBKHHaQeXWFh/fpb2zAvOs0vZQSv+jOV+bze3fE0AI7XPYKt8Sa54KPBhYls
aHsHXznhnm19cSXW/x+cloWhJu3FXKzQltxxiHCaJrgYWI8mp40MYQ225RkcyhJ4
uWTpuho6ePqlySdeq7zw0r4jRRjCy6xE7TPdX+8XjsECgYEAyZ3mM+htcNy2H9dm
XUFf9qxPE8Lx5t6Jen4vczZ+BK0hCPB1NXJxtmVULGEb051/0z2eQLk7IxZpfuXq
bhR9qDNcqzeVNPILnPjFudxk/YlbltpyMo3nN9U/vwRa0i/KXnbRTKkfCdOM/2XZ
/lzIJfQ8rS603PdXmfCHrUOr2g8CgYEAxad9J6I5u5g0LLbGAesY+8K4ESh2kHVh
W7EuHGbxMBtKFGndRITjJ85qxxUfw6eqTddYuFR22Pm98tCT1BMpFZGYGxoEdrP3
qqwbUNKcdk6zeAwooBF1q397dBJ2lR55joCVxk0/YQeXm6Dqkq5j0bA1biFKmJtE
o63An2mlocsCgYB7YAyGpyyRa/5m7cDOQDshD8A0L48n3/Xw51bSAf6LjgYxGjQf
SLEdFFS185a7oB2gfoxgvvjZN9XGuZsDUbazPvruK0064QMKQ5F7csq5+1v4rCRF
m2BqYixoD5okFOqZc8wQRU2hDbuybflAFjbEQvj+YR58OT96DB56gHahMQKBgQCW
D175pDRotFmISQtzkWXaXi8Y97tsWXGdB5uWfKFIgK9xaB5RUwKSyihPFT6UcMrf
Zks5RwckHBeWLbzOGe3rLippCQuyg1fY/+mNJxkayQ2Aatq9DARmO9cifJIDDKwF
AKK1dxhTNkxoH3d3/WZTYJBwGF5mFhu6mMPRQ4g4mQKBgQDCCiHGuBUDscDiLbSq
fn0n2cmujcxhFYzHvE9ahNTBpJErEsLG0RSp77ZK5gETYUvmuI0BrfAYgU/xaGCz
t0Rqav1kVzZH9j/hd0tavIIS1kfDL/whj/UdVeZjTiIEY9AZLcuwUHOcQesWursk
XdvExDsAdjbkBG7ynn9pmMgIJg==
-----END PRIVATE KEY-----"
                    .to_string(),
            }),
        };

        let conn_opts = ConnectOptions::new();
        let result = JetstreamActor::configure_tls(conn_opts, tls_config);

        assert!(result.is_ok());
    }

    use async_nats::jetstream::Context;
    use async_nats::jetstream::stream::Config as StreamConfig;
    use std::time::Duration;

    async fn setup_jetstream() -> (Context, String) {
        let client = async_nats::connect("localhost").await.unwrap();
        let js = async_nats::jetstream::new(client);

        let stream_name = "js_source_test_stream";
        let _ = js.delete_stream(stream_name).await;
        let stream = js
            .get_or_create_stream(StreamConfig {
                name: stream_name.to_string(),
                ..Default::default()
            })
            .await
            .unwrap();

        stream
            .get_or_create_consumer(
                stream_name,
                async_nats::jetstream::consumer::pull::Config {
                    durable_name: Some(stream_name.to_string()),
                    ..Default::default()
                },
            )
            .await
            .unwrap();

        (js, stream_name.to_string())
    }

    #[cfg(feature = "nats-tests")]
    #[tokio::test]
    async fn test_jetstream_source() {
        let _ = rustls::crypto::aws_lc_rs::default_provider().install_default();
        let (js, stream_name) = setup_jetstream().await;

        for i in 0..100 {
            js.publish(stream_name.clone(), format!("message {}", i).into())
                .await
                .unwrap();
        }

        let config = JetstreamSourceConfig {
            addr: "localhost".to_string(),
            stream: stream_name.clone(),
            consumer: JetstreamConsumerName::UserSpecified(stream_name),
            auth: None,
            tls: None,
        };

        let read_timeout = Duration::from_secs(1);
        let source = JetstreamSource::connect(config, 30, read_timeout)
            .await
            .unwrap();

        // Read messages
        let messages = source.read_messages().await.unwrap();
        assert_eq!(messages.len(), 30);
        let pending = source.pending_messages().await.unwrap();
        assert_eq!(
            pending,
            Some(100),
            "Pending messages should include unacknowledged messages"
        );

        // Ack messages
        let offsets: Vec<u64> = messages.iter().map(|msg| msg.stream_sequence).collect();
        source.ack_messages(offsets).await.unwrap();

        // Check pending messages
        // If checked immediately, Nats server intermittently returns 1 more than the actual value
        tokio::time::sleep(Duration::from_millis(30)).await;
        let pending = source.pending_messages().await.unwrap();
        assert_eq!(
            pending,
            Some(70),
            "Pending messages should be 70 after acking 30 messages"
        );

        // Read remaining messages
        let messages = source.read_messages().await.unwrap();
        assert_eq!(messages.len(), 30);

        // Ack remaining messages
        let offsets: Vec<u64> = messages.iter().map(|msg| msg.stream_sequence).collect();
        source.ack_messages(offsets).await.unwrap();

        // Check pending messages
        // If checked immediately, Nats server intermittently returns 1 more than the actual value
        tokio::time::sleep(Duration::from_millis(30)).await;
        let pending = source.pending_messages().await.unwrap();
        assert_eq!(
            pending,
            Some(40),
            "Pending messages should be 40 after acking another 30 messages"
        );

        // Read remaining messages
        let messages = source.read_messages().await.unwrap();
        assert_eq!(messages.len(), 30);

        // Ack remaining messages
        let offsets: Vec<u64> = messages.iter().map(|msg| msg.stream_sequence).collect();
        source.ack_messages(offsets).await.unwrap();

        // Check pending messages
        tokio::time::sleep(Duration::from_millis(30)).await;
        let pending = source.pending_messages().await.unwrap();
        assert_eq!(
            pending,
            Some(10),
            "Pending messages should be 10 after acking another 30 messages"
        );

        // Read remaining messages
        let messages = source.read_messages().await.unwrap();
        assert_eq!(messages.len(), 10);

        // Ack remaining messages
        let offsets: Vec<u64> = messages.iter().map(|msg| msg.stream_sequence).collect();
        source.ack_messages(offsets).await.unwrap();

        // Check pending messages
        tokio::time::sleep(Duration::from_millis(30)).await;
        let pending = source.pending_messages().await.unwrap();
        assert_eq!(
            pending,
            Some(0),
            "Pending messages should be 0 after acking all messages"
        );

        // Ensure read operation returns after the read timeout
        let start = Instant::now();
        let messages = source.read_messages().await.unwrap();
        let elapsed = start.elapsed();
        assert!(
            elapsed < read_timeout + Duration::from_millis(100),
            "Read operation should return in 1 second"
        );
        assert!(
            messages.is_empty(),
            "No messages should be returned after all messages are acked"
        );
    }
}
