use crate::{Error, NatsAuth, Result, TlsConfig, tls};
use async_nats::jetstream::consumer::{AckPolicy, DeliverPolicy};
use async_nats::jetstream::{AckKind, Message as JetstreamMessage, consumer};
use async_nats::{
    ConnectOptions,
    jetstream::consumer::{
        Consumer,
        pull::{Config, Stream},
    },
};
use backoff::retry::Retry;
use backoff::strategy::fixed;
use bytes::Bytes;
use chrono::DateTime;
use std::{collections::HashMap, time::Duration};
use tokio::sync::{mpsc, oneshot};
use tokio::task::JoinHandle;
use tokio::time::{self, Instant};
use tokio_stream::StreamExt;

#[derive(Debug, Clone, PartialEq)]
pub struct JetstreamSourceConfig {
    pub addr: String,
    pub stream: String,
    pub consumer: String,
    pub auth: Option<NatsAuth>,
    pub tls: Option<TlsConfig>,
}

/// Message represents a message received from Jetstream which can be converted to Numaflow Message.
#[derive(Debug)]
pub struct Message {
    /// The user payload.
    pub value: Bytes,
    /// Monotonically increasing sequence number as generated by JetStream.
    pub stream_sequence: u64,
    pub published_timestamp: DateTime<chrono::Utc>,
    pub headers: HashMap<String, String>,
}

impl TryFrom<JetstreamMessage> for Message {
    type Error = Error;
    fn try_from(msg: JetstreamMessage) -> Result<Self> {
        let headers = match msg.message.headers.as_ref() {
            Some(headers) => headers
                .iter()
                .map(|(k, v)| (k.to_string(), v[0].as_str().to_string())) //NOTE: we are only using the first value of the header
                .collect(),
            None => HashMap::new(),
        };

        let stream_sequence = msg
            .info()
            .map_err(|e| {
                Error::Jetstream(format!("fetching message metadata from Jetstream: {e:?}"))
            })?
            .stream_sequence;

        let published_timestamp = msg
            .info()
            .map_err(|e| {
                Error::Jetstream(format!("fetching message metadata from Jetstream: {e:?}"))
            })?
            .published;

        Ok(Message {
            value: msg.message.payload,
            stream_sequence,
            headers,
            published_timestamp: DateTime::from_timestamp(
                published_timestamp.unix_timestamp(),
                published_timestamp.nanosecond(),
            )
            .expect("Failed to convert timestamp to DateTime"),
        })
    }
}

enum JetstreamActorMessage {
    Read {
        respond_to: oneshot::Sender<Result<Vec<Message>>>,
    },
    Ack {
        offsets: Vec<u64>,
        respond_to: oneshot::Sender<Result<()>>,
    },
    Pending {
        respond_to: oneshot::Sender<Result<Option<usize>>>,
    },
}

struct JetstreamActor {
    consumer: Consumer<Config>,
    messages: Stream,
    read_timeout: Duration,
    batch_size: usize,
    in_progress_messages: HashMap<u64, MessageProcessingTracker>,
    handler_rx: mpsc::Receiver<JetstreamActorMessage>,
}

impl JetstreamActor {
    async fn start(
        config: JetstreamSourceConfig,
        batch_size: usize,
        read_timeout: Duration,
        handler_rx: mpsc::Receiver<JetstreamActorMessage>,
    ) -> Result<()> {
        let mut conn_opts = ConnectOptions::new()
            .max_reconnects(None) // unlimited reconnects
            .reconnect_delay_callback(|attempts| {
                std::time::Duration::from_millis(std::cmp::min((attempts * 10) as u64, 1000))
            })
            .ping_interval(Duration::from_secs(3))
            .retry_on_initial_connect();
        if let Some(auth) = config.auth {
            conn_opts = match auth {
                NatsAuth::Basic { username, password } => {
                    conn_opts.user_and_password(username, password)
                }
                NatsAuth::NKey(nkey) => conn_opts.nkey(nkey),
                NatsAuth::Token(token) => conn_opts.token(token),
            };
        }
        if let Some(tls_config) = config.tls {
            conn_opts = tls::configure_tls(conn_opts, tls_config)?;
        }
        let client = async_nats::connect_with_options(&config.addr, conn_opts)
            .await
            .map_err(|err| Error::Connection {
                server: config.addr.to_string(),
                error: err.to_string(),
            })?;

        let js_ctx = async_nats::jetstream::new(client);
        let consumer = js_ctx
            .get_consumer_from_stream(&config.consumer, &config.stream)
            .await;

        let consumer = match consumer {
            Ok(consumer) => consumer,
            Err(e) => {
                let async_nats::jetstream::stream::ConsumerErrorKind::JetStream(e) = e.kind()
                else {
                    return Err(Error::Jetstream(format!(
                        "Getting consumer {} from Jetstream stream {}: {e:?}",
                        config.consumer, config.stream
                    )));
                };

                if e.error_code() != async_nats::jetstream::ErrorCode::CONSUMER_NOT_FOUND {
                    return Err(Error::Jetstream(format!(
                        "Getting consumer {} from Jetstream stream {}: {e:?}",
                        config.consumer, config.stream
                    )));
                }

                tracing::info!(
                    "Consumer {} not found on stream {}. Creating new consumer.",
                    config.consumer,
                    config.stream
                );
                js_ctx
                    .create_consumer_on_stream(
                        consumer::pull::Config {
                            durable_name: Some(config.consumer.clone()),
                            description: Some("Numaflow Jetstream Consumer".into()),
                            deliver_policy: DeliverPolicy::All,
                            ack_policy: AckPolicy::Explicit,
                            ..Default::default()
                        },
                        &config.stream,
                    )
                    .await
                    .map_err(|e| {
                        Error::Jetstream(format!(
                            "Creating consumer {} on stream {}: {e:?}",
                            config.consumer, config.stream
                        ))
                    })?
            }
        };

        let message_stream = consumer.messages().await.unwrap();

        tokio::spawn(async move {
            let mut actor = JetstreamActor {
                consumer,
                messages: message_stream,
                read_timeout,
                batch_size,
                in_progress_messages: HashMap::new(),
                handler_rx,
            };
            tracing::info!("Starting Jetstream...");
            actor.run().await;
        });

        Ok(())
    }

    async fn run(&mut self) {
        while let Some(msg) = self.handler_rx.recv().await {
            self.handle_message(msg).await;
        }
    }

    async fn handle_message(&mut self, msg: JetstreamActorMessage) {
        match msg {
            JetstreamActorMessage::Read { respond_to } => {
                let messages = self.read_messages().await;
                let _ = respond_to.send(messages);
            }
            JetstreamActorMessage::Ack {
                offsets,
                respond_to,
            } => {
                let status = self.ack_messages(offsets).await;
                let _ = respond_to.send(status);
            }
            JetstreamActorMessage::Pending { respond_to } => {
                let pending = self.pending_messages().await;
                let _ = respond_to.send(pending);
            }
        }
    }

    /// Reads messages from the Jetstream stream with honoring timeouts.
    async fn read_messages(&mut self) -> Result<Vec<Message>> {
        let mut messages: Vec<Message> = vec![];
        let timeout = tokio::time::timeout(self.read_timeout, std::future::pending::<()>());
        tokio::pin!(timeout);
        loop {
            if messages.len() >= self.batch_size {
                break;
            }
            tokio::select! {
                biased;

                _ = &mut timeout => {
                    break;
                }

                message = self.messages.next() => {
                    let Some(message) = message else {
                        break;
                    };
                    let message = message
                        .map_err(|e| Error::Jetstream(format!("Getting next message from the stream: {e:?}")))?;
                    let message = self.process_message(message).await?;
                    messages.push(message);
                }
            }
        }
        tracing::debug!(msg_count = messages.len(), "Read messages from Jetstream");
        Ok(messages)
    }

    async fn ack_messages(&mut self, offsets: Vec<u64>) -> Result<()> {
        let mut tasks = Vec::with_capacity(offsets.len());

        for offset in offsets {
            let msg_task = self.in_progress_messages.remove(&offset);
            let Some(msg_task) = msg_task else {
                tracing::warn!(offset, "Received ACK request for unknown offset");
                continue;
            };

            // msg_task.ack() involves sending on a oneshot channel to an already running tokio task
            // This results in sending Ack to Nats server (within the tokio task) and awaiting for
            // the task to finish. We spawn tasks here so that acks happens concurrently.
            let task = tokio::spawn(async move {
                msg_task.ack().await;
            });
            tasks.push(task);
        }

        for task in tasks {
            if let Err(err) = task.await {
                return Err(Error::Other(format!("Error in ack task: {err:?}")));
            }
        }
        Ok(())
    }

    async fn process_message(&mut self, js_message: JetstreamMessage) -> Result<Message> {
        // we need to clone because the message should be held around for ack
        let message: Message = js_message.clone().try_into().map_err(|e| {
            Error::Jetstream(format!(
                "converting raw Jetstream message as Numaflow source message: {e:?}"
            ))
        })?;

        // we need to start WIP ack because some processing can be quite slow and we have to avoid
        // redelivery.
        let tick_interval = self.consumer.cached_info().config.ack_wait / 2;
        let message_tracker = MessageProcessingTracker::start(js_message, tick_interval).await;
        self.in_progress_messages
            .insert(message.stream_sequence, message_tracker);

        Ok(message)
    }

    pub async fn pending_messages(&mut self) -> Result<Option<usize>> {
        let x = self
            .consumer
            .info()
            .await
            .map_err(|e| Error::Jetstream(format!("Failed to get consumer info: {e:?}")))?;

        Ok(Some(x.num_pending as usize + x.num_ack_pending))
    }
}

#[derive(Clone)]
pub struct JetstreamSource {
    actor_tx: mpsc::Sender<JetstreamActorMessage>,
}

impl JetstreamSource {
    pub async fn connect(
        config: JetstreamSourceConfig,
        batch_size: usize,
        read_timeout: Duration,
    ) -> Result<Self> {
        let (tx, rx) = mpsc::channel(10);
        JetstreamActor::start(config, batch_size, read_timeout, rx).await?;
        Ok(Self { actor_tx: tx })
    }

    pub async fn read_messages(&self) -> Result<Vec<Message>> {
        let (tx, rx) = oneshot::channel();
        let msg = JetstreamActorMessage::Read { respond_to: tx };
        let _ = self.actor_tx.send(msg).await;
        rx.await
            .map_err(|_| Error::Other("Actor task terminated".into()))?
    }

    pub async fn ack_messages(&self, offsets: Vec<u64>) -> Result<()> {
        let (tx, rx) = oneshot::channel();
        let msg = JetstreamActorMessage::Ack {
            offsets,
            respond_to: tx,
        };
        let _ = self.actor_tx.send(msg).await;
        rx.await
            .map_err(|_| Error::Other("Actor task terminated".into()))?
    }

    pub async fn pending_messages(&self) -> Result<Option<usize>> {
        let (tx, rx) = oneshot::channel();
        let msg = JetstreamActorMessage::Pending { respond_to: tx };
        let _ = self.actor_tx.send(msg).await;
        rx.await
            .map_err(|_| Error::Other("Actor task terminated".into()))?
    }
}

/// The MessageProcessingTracker object is a handle to the work-in-progress background task for a
/// message. The background task periodically sends `AckKind::Progress` to the Nats server while the
/// message is being processed. This handle will be tracked as value in a hashmap in the Jetstream
/// source handle where the key will be the corresponding message sequence id (offset).
/// When the `Sourcer` trait's ack is called, the `MessageProcessingTracker::ack` gets called, which
/// results in marking the message processing completion in Nats server and termination of the
/// work-in-progress task.
struct MessageProcessingTracker {
    in_progress_task: JoinHandle<()>,
    ack_signal_tx: oneshot::Sender<()>,
}

// same as rust/numaflow-core/src/pipeline/isb/jestream/reader.rs
const ACK_RETRY_INTERVAL: u64 = 100;
const ACK_RETRY_ATTEMPTS: usize = usize::MAX;

impl MessageProcessingTracker {
    async fn start(msg: JetstreamMessage, tick: Duration) -> Self {
        let (ack_signal_tx, ack_signal_rx) = oneshot::channel();
        let task = tokio::spawn(Self::start_work_in_progress(msg, tick, ack_signal_rx));
        Self {
            in_progress_task: task,
            ack_signal_tx,
        }
    }

    /// Starts a background task to send an ACK to Jetstream for the message. It will do the final
    /// ACK/NACK after the task is completed.
    async fn start_work_in_progress(
        msg: JetstreamMessage,
        tick: Duration,
        ack_signal_rx: oneshot::Receiver<()>,
    ) {
        let start = Instant::now();
        let mut interval = time::interval_at(start + tick, tick);

        let ack_retry_interval =
            fixed::Interval::from_millis(ACK_RETRY_INTERVAL).take(ACK_RETRY_ATTEMPTS);
        let nack_retry_interval =
            fixed::Interval::from_millis(ACK_RETRY_INTERVAL).take(ACK_RETRY_ATTEMPTS);

        let ack_msg = async || {
            if let Err(err) = msg.ack().await {
                tracing::error!(?err, "Failed to Ack message");
                return Err(format!("Acknowledging Jetstream message: {err:?}"));
            }
            Ok(())
        };

        let ack_with_retry = Retry::new(ack_retry_interval, ack_msg, |_: &String| true);

        let ack_in_progress = async || {
            let ack_result = msg.ack_with(AckKind::Progress).await;
            if let Err(e) = ack_result {
                tracing::error!(?e, "Failed to send InProgress Ack to Jetstream for message");
            }
        };

        let nack_msg = async || {
            let ack_result = msg.ack_with(AckKind::Nak(None)).await;
            if let Err(e) = ack_result {
                tracing::error!(?e, "Failed to send InProgress Ack to Jetstream for message");
                return Err(format!(
                    "Sending Negative Ack to Jetstream for the message: {e:?}"
                ));
            }
            Ok(())
        };

        let nack_with_retry = Retry::new(nack_retry_interval, nack_msg, |_: &String| true);

        tokio::pin!(ack_signal_rx);

        loop {
            let ack = tokio::select! {
                biased;

                ack = &mut ack_signal_rx => ack,
                _ = interval.tick() => {
                    ack_in_progress().await;
                    continue;
                },
            };

            if let Err(e) = ack {
                tracing::error!(error=?e, "Received error while waiting for Ack on oneshot channel");
                if let Err(e) = nack_with_retry.await {
                    tracing::error!(error=?e, "Failed to send Negative Ack for the jetstream message even after retries");
                }
            }
            break;
        }
        if let Err(e) = ack_with_retry.await {
            tracing::error!(error=?e, "Failed to ACK jetstream message even after retries");
        }
    }

    async fn ack(self) {
        let Self {
            in_progress_task,
            ack_signal_tx,
        } = self;
        if let Err(err) = ack_signal_tx.send(()) {
            tracing::error!(
                ?err,
                "Background task to mark the message status as in-progress is already terminated"
            );
            return;
        }
        let _ = in_progress_task.await;
    }
}

#[cfg(test)]
mod tests {

    use super::*;

    use async_nats::jetstream::Context;
    use async_nats::jetstream::stream::Config as StreamConfig;
    use std::time::Duration;

    async fn setup_jetstream(stream_name: &str, create_consumer: bool) -> Context {
        let client = async_nats::connect("localhost").await.unwrap();
        let js = async_nats::jetstream::new(client);

        let _ = js.delete_stream(stream_name).await;
        let stream = js
            .get_or_create_stream(StreamConfig {
                name: stream_name.to_string(),
                ..Default::default()
            })
            .await
            .unwrap();

        if create_consumer {
            stream
                .get_or_create_consumer(
                    stream_name,
                    async_nats::jetstream::consumer::pull::Config {
                        durable_name: Some(stream_name.to_string()),
                        ..Default::default()
                    },
                )
                .await
                .unwrap();
        }

        js
    }

    async fn source_functionality_test(
        source: JetstreamSource,
        js: Context,
        stream_name: &'static str,
    ) {
        for i in 0..100 {
            js.publish(stream_name, format!("message {}", i).into())
                .await
                .unwrap();
        }
        let read_timeout = Duration::from_secs(1);
        // Read messages
        let messages = source.read_messages().await.unwrap();
        assert_eq!(messages.len(), 30);
        let pending = source.pending_messages().await.unwrap();
        assert_eq!(
            pending,
            Some(100),
            "Pending messages should include unacknowledged messages"
        );

        // Ack messages
        let offsets: Vec<u64> = messages.iter().map(|msg| msg.stream_sequence).collect();
        source.ack_messages(offsets).await.unwrap();

        // Check pending messages
        // If checked immediately, Nats server intermittently returns 1 more than the actual value
        tokio::time::sleep(Duration::from_millis(30)).await;
        let pending = source.pending_messages().await.unwrap();
        assert_eq!(
            pending,
            Some(70),
            "Pending messages should be 70 after acking 30 messages"
        );

        // Read remaining messages
        let messages = source.read_messages().await.unwrap();
        assert_eq!(messages.len(), 30);

        // Ack remaining messages
        let offsets: Vec<u64> = messages.iter().map(|msg| msg.stream_sequence).collect();
        source.ack_messages(offsets).await.unwrap();

        // Check pending messages
        // If checked immediately, Nats server intermittently returns 1 more than the actual value
        tokio::time::sleep(Duration::from_millis(30)).await;
        let pending = source.pending_messages().await.unwrap();
        assert_eq!(
            pending,
            Some(40),
            "Pending messages should be 40 after acking another 30 messages"
        );

        // Read remaining messages
        let messages = source.read_messages().await.unwrap();
        assert_eq!(messages.len(), 30);

        // Ack remaining messages
        let offsets: Vec<u64> = messages.iter().map(|msg| msg.stream_sequence).collect();
        source.ack_messages(offsets).await.unwrap();

        // Check pending messages
        tokio::time::sleep(Duration::from_millis(30)).await;
        let pending = source.pending_messages().await.unwrap();
        assert_eq!(
            pending,
            Some(10),
            "Pending messages should be 10 after acking another 30 messages"
        );

        // Read remaining messages
        let messages = source.read_messages().await.unwrap();
        assert_eq!(messages.len(), 10);

        // Ack remaining messages
        let offsets: Vec<u64> = messages.iter().map(|msg| msg.stream_sequence).collect();
        source.ack_messages(offsets).await.unwrap();

        // Check pending messages
        tokio::time::sleep(Duration::from_millis(30)).await;
        let pending = source.pending_messages().await.unwrap();
        assert_eq!(
            pending,
            Some(0),
            "Pending messages should be 0 after acking all messages"
        );

        // Ensure read operation returns after the read timeout
        let start = Instant::now();
        let messages = source.read_messages().await.unwrap();
        let elapsed = start.elapsed();
        assert!(
            elapsed < read_timeout + Duration::from_millis(100),
            "Read operation should return in 1 second"
        );
        assert!(
            messages.is_empty(),
            "No messages should be returned after all messages are acked"
        );
    }

    #[cfg(feature = "nats-tests")]
    #[tokio::test]
    async fn test_jetstream_source_consumer_exists_on_stream() {
        let _ = rustls::crypto::aws_lc_rs::default_provider().install_default();

        let stream_name = "test_jetstream_source_consumer_exists_on_stream";
        let js = setup_jetstream(stream_name, true).await;
        let config = JetstreamSourceConfig {
            addr: "localhost".to_string(),
            stream: stream_name.into(),
            consumer: stream_name.into(),
            auth: None,
            tls: None,
        };
        let source = JetstreamSource::connect(config, 30, Duration::from_secs(1))
            .await
            .unwrap();

        source_functionality_test(source, js, stream_name).await;
    }

    #[cfg(feature = "nats-tests")]
    #[tokio::test]
    async fn test_jetstream_source_consumer_not_exists_on_stream() {
        let _ = rustls::crypto::aws_lc_rs::default_provider().install_default();

        let stream_name = "test_jetstream_source_consumer_not_exists_on_stream";
        let js = setup_jetstream(stream_name, false).await;
        let config = JetstreamSourceConfig {
            addr: "localhost".to_string(),
            stream: stream_name.into(),
            consumer: stream_name.into(),
            auth: None,
            tls: None,
        };
        let source = JetstreamSource::connect(config, 30, Duration::from_secs(1))
            .await
            .unwrap();

        source_functionality_test(source, js, stream_name).await;
    }
}
